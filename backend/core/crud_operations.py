# CRUD operations for database interaction
import asyncpg
from typing import Optional, Any, Dict
from uuid import uuid4, UUID
from datetime import datetime

from ..models.user_models import UserModel, UserCreate
from ..models.multimodal_models import AudiovisualGesturalChunkModel
from ..models.learning_log_models import TriaLearningLogModel


async def create_user(db: asyncpg.Connection, *, user_create: UserCreate) -> UserModel:
    """
    Creates a new user record in the database.

    Args:
        db: An active asyncpg database connection.
        user_create: A Pydantic UserCreate model containing the user data to create.
                     The `user_id_firebase` field will be used as the `user_id` primary key
                     in the 'users' table.

    Returns:
        A UserModel instance representing the created user, including data
        fetched from the database (like created_at, updated_at) and a locally
        generated UUID for the 'id' field to satisfy the BaseModel requirements.

    Raises:
        asyncpg.PostgresError: If a database error occurs (e.g., unique constraint violation).
    """
    sql = """
        INSERT INTO users (user_id, email)
        VALUES ($1, $2)
        RETURNING user_id, email, created_at, updated_at;
    """
    try:
        row = await db.fetchrow(sql, user_create.user_id_firebase, user_create.email)
        if row:
            return UserModel(
                id=uuid4(), # Not from DB, generated locally, but required by BaseUUIDModel
                user_id_firebase=row['user_id'],
                email=row['email'],
                created_at=row['created_at'],
                updated_at=row['updated_at']
            )
        else:
            raise Exception("User creation failed, no data returned.")

    except asyncpg.UniqueViolationError as e:
        print(f"Error creating user: {e}") # Replace with proper logging
        raise # Re-raise the exception


async def get_user_by_firebase_uid(db: asyncpg.Connection, firebase_uid: str) -> Optional[UserModel]:
    """
    Retrieves a user from the database by their Firebase UID.

    Args:
        db: An active asyncpg database connection.
        firebase_uid: The Firebase UID (maps to 'user_id' column) of the user to retrieve.

    Returns:
        A UserModel instance if the user is found, otherwise None.
        The 'id' (UUID) field of the returned UserModel is generated locally
        as it's not stored in the 'users' table, but required by BaseUUIDModel.
    """
    sql = """
        SELECT user_id, email, created_at, updated_at
        FROM users
        WHERE user_id = $1;
    """
    row = await db.fetchrow(sql, firebase_uid)
    if row:
        return UserModel(
            id=uuid4(), # Not from DB, generated locally, but required by BaseUUIDModel
            user_id_firebase=row['user_id'],
            email=row['email'],
            created_at=row['created_at'],
            updated_at=row['updated_at']
        )
    return None


async def create_tria_learning_log_entry(
    db: asyncpg.Connection, *, log_entry_create: TriaLearningLogModel
) -> TriaLearningLogModel:
    """
    Creates a new Tria learning log entry in the database.
    The `log_id` is auto-generated by the database.
    The `timestamp` from the input model is used.
    """
    sql = """
        INSERT INTO tria_learning_log (
            user_id, session_id, event_type, bot_affected_id, summary_text,
            prompt_text, tria_response_text, model_used, feedback_score, custom_data,
            timestamp
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
        )
        RETURNING
            log_id, user_id, session_id, event_type, bot_affected_id, summary_text,
            prompt_text, tria_response_text, model_used, feedback_score, custom_data,
            timestamp;
    """
    try:
        row = await db.fetchrow(
            sql,
            log_entry_create.user_id,
            log_entry_create.session_id,
            log_entry_create.event_type,
            log_entry_create.bot_affected_id,
            log_entry_create.summary_text,
            log_entry_create.prompt_text,
            log_entry_create.tria_response_text,
            log_entry_create.model_used,
            log_entry_create.feedback_score,
            log_entry_create.custom_data,
            log_entry_create.timestamp,
        )
        if row:
            return TriaLearningLogModel(
                log_id=row['log_id'],
                user_id=row['user_id'],
                session_id=row['session_id'],
                event_type=row['event_type'],
                bot_affected_id=row['bot_affected_id'],
                summary_text=row['summary_text'],
                prompt_text=row['prompt_text'],
                tria_response_text=row['tria_response_text'],
                model_used=row['model_used'],
                feedback_score=row['feedback_score'],
                custom_data=row['custom_data'],
                timestamp=row['timestamp']
            )
        else:
            raise Exception("TriaLearningLog entry creation failed, no data returned.")
    except asyncpg.PostgresError as e:
        print(f"Error creating Tria learning log entry: {e}") # Replace with proper logging
        raise


async def create_audiovisual_gestural_chunk(
    db: asyncpg.Connection, *, chunk_create: AudiovisualGesturalChunkModel
) -> AudiovisualGesturalChunkModel:
    """
    Creates a new audiovisual/gestural chunk record in the database.
    The `id` field of the input `chunk_create` model (which is a UUID) is used as `chunk_id` PK.
    `created_at` and `updated_at` are set by the database.
    """
    sql = """
        INSERT INTO audiovisual_gestural_chunks (
            chunk_id, user_id, chunk_type, storage_ref,
            original_filename, mime_type, duration_seconds,
            resolution_width, resolution_height,
            tria_processing_status, tria_extracted_features_json,
            related_gesture_id, related_hologram_id, custom_metadata_json
            -- created_at and updated_at are handled by DB defaults
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
        )
        RETURNING
            chunk_id, user_id, chunk_type, storage_ref,
            original_filename, mime_type, duration_seconds,
            resolution_width, resolution_height,
            tria_processing_status, tria_extracted_features_json,
            related_gesture_id, related_hologram_id, custom_metadata_json,
            created_at, updated_at;
    """
    try:
        row = await db.fetchrow(
            sql,
            chunk_create.id,  # Maps to chunk_id
            chunk_create.user_id,
            chunk_create.chunk_type,
            chunk_create.storage_ref,
            chunk_create.original_filename,
            chunk_create.mime_type,
            chunk_create.duration_seconds,
            chunk_create.resolution_width,
            chunk_create.resolution_height,
            chunk_create.tria_processing_status,
            chunk_create.tria_extracted_features_json,
            chunk_create.related_gesture_id,
            chunk_create.related_hologram_id,
            chunk_create.custom_metadata_json,
        )
        if row:
            return AudiovisualGesturalChunkModel(
                id=row['chunk_id'],
                user_id=row['user_id'],
                chunk_type=row['chunk_type'],
                storage_ref=row['storage_ref'],
                original_filename=row['original_filename'],
                mime_type=row['mime_type'],
                duration_seconds=row['duration_seconds'],
                resolution_width=row['resolution_width'],
                resolution_height=row['resolution_height'],
                tria_processing_status=row['tria_processing_status'],
                tria_extracted_features_json=row['tria_extracted_features_json'],
                related_gesture_id=row['related_gesture_id'],
                related_hologram_id=row['related_hologram_id'],
                custom_metadata_json=row['custom_metadata_json'],
                created_at=row['created_at'],
                updated_at=row['updated_at']
            )
        else:
            raise Exception("AudiovisualGesturalChunk creation failed, no data returned.")
    except asyncpg.PostgresError as e:
        print(f"Error creating audiovisual/gestural chunk: {e}") # Replace with proper logging
        raise


async def get_chunk_by_id(db: asyncpg.Connection, chunk_id: UUID) -> Optional[AudiovisualGesturalChunkModel]:
    """
    Retrieves an audiovisual/gestural chunk from the database by its ID.
    """
    sql = """
        SELECT
            chunk_id, user_id, chunk_type, storage_ref,
            original_filename, mime_type, duration_seconds,
            resolution_width, resolution_height,
            tria_processing_status, tria_extracted_features_json,
            related_gesture_id, related_hologram_id, custom_metadata_json,
            created_at, updated_at
        FROM audiovisual_gestural_chunks
        WHERE chunk_id = $1;
    """
    row = await db.fetchrow(sql, chunk_id)
    if row:
        return AudiovisualGesturalChunkModel(
            id=row['chunk_id'],
            user_id=row['user_id'],
            chunk_type=row['chunk_type'],
            storage_ref=row['storage_ref'],
            original_filename=row['original_filename'],
            mime_type=row['mime_type'],
            duration_seconds=row['duration_seconds'],
            resolution_width=row['resolution_width'],
            resolution_height=row['resolution_height'],
            tria_processing_status=row['tria_processing_status'],
            tria_extracted_features_json=row['tria_extracted_features_json'],
            related_gesture_id=row['related_gesture_id'],
            related_hologram_id=row['related_hologram_id'],
            custom_metadata_json=row['custom_metadata_json'],
            created_at=row['created_at'],
            updated_at=row['updated_at']
        )
    return None
