# backend/core/crud_operations.py
# CRUD operations for database interaction
"""This module provides Create, Read, Update, and Delete (CRUD) operations
for interacting with the PostgreSQL database. It encapsulates the SQL queries
and basic error handling for various data models used in the application.
"""

import asyncpg
from typing import Optional, Any, Dict, List
from uuid import uuid4, UUID
from datetime import datetime
import logging

# Import Pydantic models from their respective modules
from ..models.user_models import UserInDB
from ..models.multimodal_models import AudiovisualGesturalChunkModel, UserGestureModel
from ..models.learning_log_models import TriaLearningLogModel
from ..models.hologram_models import UserHologramResponseModel # Модель для ответа по голограммам

# Configure logging for this module
logger = logging.getLogger(__name__)


async def get_user_by_firebase_uid(db: asyncpg.Connection, firebase_uid: str) -> Optional[UserInDB]:
    """
    Retrieves a user from the database by their Firebase UID.

    Args:
        db: An active asyncpg database connection.
        firebase_uid: The Firebase UID (maps to 'user_id' column in DB) of the user to retrieve.

    Returns:
        A UserInDB instance if the user is found, otherwise None.
        A locally generated UUID for the 'id' field is added if UserInDB expects it.
    
    Raises:
        asyncpg.PostgresError: If a database error occurs during the fetch operation.
    """
    sql = """
        SELECT user_id, email, created_at, updated_at
        FROM users
        WHERE user_id = $1;
    """
    logger.info(f"Attempting to retrieve user with Firebase UID: {firebase_uid}")
    try:
        row = await db.fetchrow(sql, firebase_uid)
        if row:
            user_data = dict(row)
            if 'user_id' in user_data and 'user_id_firebase' not in user_data:
                user_data['user_id_firebase'] = user_data.pop('user_id')
            
            if hasattr(UserInDB, 'id') and not 'id' in user_data: # If UserInDB expects an 'id' (e.g. from BaseUUIDModel)
                user_data['id'] = uuid4() # This ID is not from the 'users' table.

            user = UserInDB(**user_data)
            logger.info(f"User {firebase_uid} found in database.")
            return user
        else:
            logger.info(f"User with Firebase UID {firebase_uid} not found in database.")
            return None
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while fetching user by Firebase UID {firebase_uid}.")
        raise


async def create_tria_learning_log_entry(
    db: asyncpg.Connection, *, log_entry_create: TriaLearningLogModel
) -> TriaLearningLogModel:
    """
    Creates a new Tria learning log entry in the database.
    The `log_id` is auto-generated by the database.
    """
    sql = """
        INSERT INTO tria_learning_log (
            user_id, session_id, event_type, bot_affected_id, summary_text,
            prompt_text, tria_response_text, model_used, feedback_score, custom_data,
            timestamp
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING log_id, user_id, session_id, event_type, bot_affected_id, summary_text,
                  prompt_text, tria_response_text, model_used, feedback_score, custom_data,
                  timestamp;
    """
    logger.info(f"Attempting to create Tria learning log entry for user: {log_entry_create.user_id}, event: {log_entry_create.event_type}")
    try:
        row = await db.fetchrow(
            sql,
            log_entry_create.user_id,
            log_entry_create.session_id, # Assuming this can be str or UUID compatible with DB type
            log_entry_create.event_type,
            log_entry_create.bot_affected_id,
            log_entry_create.summary_text,
            log_entry_create.prompt_text,
            log_entry_create.tria_response_text,
            log_entry_create.model_used,
            log_entry_create.feedback_score,
            log_entry_create.custom_data, # Pydantic model has custom_data
            log_entry_create.timestamp,
        )
        if row:
            created_log = TriaLearningLogModel(**dict(row))
            logger.info(f"Tria learning log entry created with log_id: {created_log.log_id}")
            return created_log
        else:
            logger.error(f"TriaLearningLog entry creation failed, no data returned for user: {log_entry_create.user_id}")
            raise Exception("TriaLearningLog entry creation failed, no data returned.")
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while creating Tria learning log entry for user {log_entry_create.user_id}.")
        raise
    except Exception as e: # Catching broader exceptions for unexpected issues
        logger.exception(f"An unexpected error occurred while creating Tria learning log entry for user {log_entry_create.user_id}.")
        raise


async def create_audiovisual_gestural_chunk(
    db: asyncpg.Connection, *, chunk_create: AudiovisualGesturalChunkModel
) -> AudiovisualGesturalChunkModel:
    """
    Creates a new audiovisual/gestural chunk record in the database.
    """
    sql = """
        INSERT INTO audiovisual_gestural_chunks (
            chunk_id, user_id, chunk_type, storage_ref,
            original_filename, mime_type, duration_seconds,
            resolution_width, resolution_height,
            tria_processing_status, tria_extracted_features_json,
            related_gesture_id, related_hologram_id, custom_metadata_json
            -- created_at and updated_at are handled by DB defaults in schema.sql
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        RETURNING chunk_id, user_id, chunk_type, storage_ref,
                  original_filename, mime_type, duration_seconds,
                  resolution_width, resolution_height,
                  tria_processing_status, tria_extracted_features_json,
                  related_gesture_id, related_hologram_id, custom_metadata_json,
                  created_at, updated_at;
    """
    logger.info(f"Attempting to create audiovisual/gestural chunk with ID: {chunk_create.id} for user: {chunk_create.user_id}")
    try:
        row = await db.fetchrow(
            sql,
            chunk_create.id,
            chunk_create.user_id,
            chunk_create.chunk_type,
            chunk_create.storage_ref,
            chunk_create.original_filename,
            chunk_create.mime_type,
            chunk_create.duration_seconds,
            chunk_create.resolution_width,
            chunk_create.resolution_height,
            chunk_create.tria_processing_status,
            chunk_create.tria_extracted_features_json,
            chunk_create.related_gesture_id, # This should be int as per recent model changes
            chunk_create.related_hologram_id,
            chunk_create.custom_metadata_json,
        )
        if row:
            # Map chunk_id from DB to 'id' in Pydantic model
            row_data = dict(row)
            if 'chunk_id' in row_data and 'id' not in row_data:
                 row_data['id'] = row_data.pop('chunk_id')

            created_chunk = AudiovisualGesturalChunkModel(**row_data)
            logger.info(f"Audiovisual/gestural chunk {created_chunk.id} created successfully for user {created_chunk.user_id}.")
            return created_chunk
        else:
            logger.error(f"AudiovisualGesturalChunk creation failed, no data returned for ID: {chunk_create.id}")
            raise Exception("AudiovisualGesturalChunk creation failed, no data returned.")
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while creating audiovisual/gestural chunk {chunk_create.id} for user {chunk_create.user_id}.")
        raise
    except Exception as e:
        logger.exception(f"An unexpected error occurred while creating audiovisual/gestural chunk {chunk_create.id} for user {chunk_create.user_id}.")
        raise


async def get_chunk_by_id(db: asyncpg.Connection, chunk_id: UUID) -> Optional[AudiovisualGesturalChunkModel]:
    """
    Retrieves an audiovisual/gestural chunk from the database by its ID.
    """
    sql = """
        SELECT chunk_id, user_id, chunk_type, storage_ref,
               original_filename, mime_type, duration_seconds,
               resolution_width, resolution_height,
               tria_processing_status, tria_extracted_features_json,
               related_gesture_id, related_hologram_id, custom_metadata_json,
               created_at, updated_at
        FROM audiovisual_gestural_chunks
        WHERE chunk_id = $1;
    """
    logger.info(f"Attempting to retrieve audiovisual/gestural chunk with ID: {chunk_id}")
    try:
        row = await db.fetchrow(sql, chunk_id)
        if row:
            row_data = dict(row)
            if 'chunk_id' in row_data and 'id' not in row_data:
                 row_data['id'] = row_data.pop('chunk_id')
            chunk = AudiovisualGesturalChunkModel(**row_data)
            logger.info(f"Audiovisual/gestural chunk {chunk_id} found.")
            return chunk
        else:
            logger.info(f"Audiovisual/gestural chunk with ID {chunk_id} not found.")
            return None
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while fetching audiovisual/gestural chunk by ID {chunk_id}.")
        raise
    except Exception as e:
        logger.exception(f"An unexpected error occurred while fetching audiovisual/gestural chunk by ID {chunk_id}.")
        raise

# --- Функция для получения жестов пользователя (из ветки main / PR #56) ---
async def get_gestures_by_user_id(db: asyncpg.Connection, user_id: str) -> List[UserGestureModel]:
    """
    Retrieves all gestures for a given user_id from the user_gestures table.
    """
    sql = """
        SELECT gesture_id, user_id, gesture_name, created_at, thumbnail_url
        FROM user_gestures
        WHERE user_id = $1
        ORDER BY created_at DESC;
    """
    logger.info(f"Attempting to retrieve gestures for user_id: {user_id}")
    try:
        rows = await db.fetch(sql, user_id)
        gestures = []
        if rows:
            for row_dict in rows:
                gestures.append(UserGestureModel(**dict(row_dict)))
            logger.info(f"Found {len(gestures)} gestures for user_id: {user_id}")
        else:
            logger.info(f"No gestures found for user_id: {user_id}")
        return gestures
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while fetching gestures for user_id {user_id}: {e}")
        raise
    except Exception as e:
        logger.exception(f"An unexpected error occurred while fetching gestures for user_id {user_id}: {e}")
        raise

# --- Функция для получения голограмм пользователя (из ветки feature/backend-my-holograms-jules / PR #57) ---
async def get_holograms_by_user_id(db: asyncpg.Connection, user_id: str) -> List[UserHologramResponseModel]:
    """
    Retrieves all holograms associated with a specific user_id from the user_holograms table.
    """
    # В схеме user_holograms поля: hologram_id (PK, UUID), user_id (TEXT), hologram_name (TEXT), definition_json (JSONB), created_at, updated_at
    # UserHologramResponseModel ожидает: hologram_id (int), hologram_name (str), created_at (datetime), preview_url (Optional[str])
    # Из-за несоответствия типа hologram_id (UUID в БД, int в модели ответа), SQL-запрос и маппинг нужно скорректировать,
    # Либо модель UserHologramResponseModel должна ожидать UUID.
    # Пока оставляем как было в ветке Jules, но это потенциальная проблема.
    # Также, `user_holograms.id` не существует, есть `hologram_id`.
    sql = """
        SELECT hologram_id, hologram_name, created_at 
        FROM user_holograms 
        WHERE user_id = $1
        ORDER BY created_at DESC;
    """
    logger.info(f"Fetching holograms for user_id: {user_id}")
    try:
        rows = await db.fetch(sql, user_id)
        holograms = []
        if rows:
            for row_dict in rows:
                # Преобразуем UUID hologram_id в int для UserHologramResponseModel - ЭТО НЕКОРРЕКТНО!
                # Правильнее было бы, чтобы UserHologramResponseModel принимала UUID или str.
                # Или если hologram_id в таблице user_holograms действительно SERIAL (int), то все ок.
                # Судя по schema.sql, user_holograms.hologram_id UUID PRIMARY KEY DEFAULT gen_random_uuid()
                # Значит, UserHologramResponseModel.hologram_id должна быть UUID или str.
                # Пока оставляем как есть, предполагая, что модель ответа будет исправлена,
                # или что в таблице user_holograms id - это SERIAL int, а не UUID.
                # В отчете Jules модель UserHologramResponseModel имела hologram_id: int.
                holograms.append(
                    UserHologramResponseModel(
                        hologram_id=row_dict['hologram_id'], # Если в БД UUID, а модель ждет int, будет ошибка
                        hologram_name=row_dict['hologram_name'],
                        created_at=row_dict['created_at'],
                        preview_url=None 
                    )
                )
            logger.info(f"Found {len(holograms)} holograms for user_id: {user_id}")
        else:
            logger.info(f"No holograms found for user_id: {user_id}")
        return holograms
    except asyncpg.PostgresError as e:
        logger.exception(f"Database error while fetching holograms for user_id {user_id}: {e}")
        raise
    except Exception as e:
        logger.exception(f"An unexpected error occurred while fetching holograms for user_id {user_id}: {e}")
        raise