# .env.example

# === Backend Security (For custom JWTs if generated by the application; less critical if relying purely on Firebase Auth for function security) ===
# SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES are typically used if your application issues its own JWTs.
# Firebase Authentication tokens are validated using the Firebase Admin SDK, which doesn't require these specific env vars for that purpose.
SECRET_KEY="your_super_secret_key_for_custom_jwts_#_CHANGE_THIS_IN_YOUR_ACTUAL_.env_FILE!"
ALGORITHM="HS256" # Algorithm for custom JWTs
ACCESS_TOKEN_EXPIRE_MINUTES="30" # Expiry for custom JWTs

# === Initial User Credentials (for first-time database seeding, e.g., via a local script or a one-time setup Cloud Function) ===
INITIAL_ADMIN_EMAIL="admin@example.com"
INITIAL_ADMIN_PASSWORD="change_this_strong_password_admin_#_CHANGE_THIS_IN_YOUR_ACTUAL_.env_FILE!"
INITIAL_TEST_USER_EMAIL="testuser@example.com"
INITIAL_TEST_USER_PASSWORD="change_this_strong_password_testuser_#_CHANGE_THIS_IN_YOUR_ACTUAL_.env_FILE!"

# === LLM Configuration (Ensure these are configured in Firebase Functions environment or via Secret Manager for deployed functions) ===
# OPENROUTER_API_KEY="your_openrouter_api_key" # Example if using OpenRouter (can be deprecated if not used)
MISTRAL_API_KEY="your_mistral_api_key" # For Mistral/Codestral models
GOOGLE_GEMINI_API_KEY="your_google_gemini_api_key" # For Google Gemini models via Firebase AI / Vertex AI or direct calls
DEFAULT_LLM_MODEL="mistralai/mistral-small-latest" # Example: default model for Tria
CODESTRAL_LLM_MODEL_NAME="mistralai/codestral-latest" # Example: specific model for code-related tasks

# === Firebase Client-Side SDK Configuration (for frontend/js/core/firebaseInit.js) ===
# These are typically public. Get them from your Firebase project console.
FIREBASE_API_KEY="your_firebase_api_key"
FIREBASE_AUTH_DOMAIN="your_project_id.firebaseapp.com"
FIREBASE_PROJECT_ID="your_project_id"
FIREBASE_STORAGE_BUCKET="your_project_id.appspot.com"
FIREBASE_MESSAGING_SENDER_ID="your_firebase_messaging_sender_id"
FIREBASE_APP_ID="your_firebase_app_id"
FIREBASE_MEASUREMENT_ID="your_firebase_measurement_id" # Optional, for Analytics

# === Google Cloud Configuration (for Backend - Cloud Functions, Storage, Pub/Sub, etc.) ===
# GOOGLE_CLOUD_PROJECT="your_google_cloud_project_id" # Often same as FIREBASE_PROJECT_ID
# GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/service-account-key.json" # For backend services if NOT running on GCP infra (e.g. local dev)
                                                                       # When deployed on Cloud Functions/Run, credentials are often inferred.
# Cloud SQL Instance Connection Name (for Cloud Run/Functions connection via proxy)
# Format: "your_project_id:your_region:your_instance_name"
# CLOUD_SQL_INSTANCE_CONNECTION_NAME="" # Relevant for Cloud SQL, less so for Neon.tech direct connections

# Pub/Sub Topics (examples, if used for async Cloud Function tasks)
# PUB_SUB_TOPIC_CHUNK_PROCESSING="tria-chunk-processing-topic"

# Genkit (Future Integration - these are illustrative and may change)
# GENKIT_API_KEY="your_genkit_api_key" # Genkit typically uses Application Default Credentials on GCP
# GENKIT_FLOW_RUNNER_URL_TRIA_CHAT="your_genkit_http_flow_url_for_tria_chat"

# === Database Configuration (Primary for MVP: Neon.tech PostgreSQL) ===

# --- Option 1: Neon.tech PostgreSQL (Primary for MVP - "no credit card" free tier) ---
# Get this full connection string from your Neon.tech project dashboard.
# This single URL is often sufficient for pg_connector.py.
NEON_DATABASE_URL="postgresql://user:password@project-id.cloud.neon.tech/dbname?sslmode=require"
# Alternatively, if your connector uses individual params:
# POSTGRES_USER="your_neon_user"
# POSTGRES_PASSWORD="your_neon_password"
# POSTGRES_HOST="project-id.cloud.neon.tech" # Host from Neon
# POSTGRES_DB="dbname" # DB name from Neon
# POSTGRES_PORT="5432" # Standard PostgreSQL port

# --- Option 2: Google Cloud SQL (Alternative, may involve billing/credit card) ---
# CLOUD_SQL_INSTANCE_CONNECTION_NAME_ALT="your_project_id:your_region:your_instance_name" # For Cloud SQL Proxy
# DB_USER_ALT="your_cloudsql_user"
# DB_PASSWORD_ALT="your_cloudsql_password"
# DB_NAME_ALT="holograms_db"
# DB_PORT_ALT="5432" # Not used if connecting via Unix socket with proxy

# --- Option 3: Local PostgreSQL Development Setup (for local testing, e.g. via Docker) ---
POSTGRES_USER_LOCAL="postgres" # Your local PostgreSQL user
POSTGRES_PASSWORD_LOCAL="your_local_password"
POSTGRES_HOST_LOCAL="localhost"
POSTGRES_DB_LOCAL="holograms_db_local"
POSTGRES_PORT_LOCAL="5432"

# === PostgreSQL Pool Configuration (Optional, for `asyncpg` pool in Cloud Functions if needed) ===
# POSTGRES_POOL_MIN_SIZE="5"
# POSTGRES_POOL_MAX_SIZE="20"

# === Other Application-Specific Variables ===
# FRONTEND_URL="http://localhost:3000" # For CORS or links, if backend needs to know
LOG_LEVEL="INFO" # DEBUG, INFO, WARNING, ERROR
