# Архитектура Потоков Данных и Взаимодействия Проекта "Голографические Медиа"

## 1. Сценарий: Взаимодействие Пользователя с Голограммой (Жест -> Звук/Визуализация)
Ввод Пользователя (Frontend):
Жест: Пользователь совершает жест рукой перед камерой.
Захват: frontend/js/multimodal/handsTracking.js (используя MediaPipe) захватывает координаты ключевых точек руки (landmark_data).
Видео/Аудио Контекст: Одновременно frontend/js/core/dataCapture.js (или аналогичный модуль) может захватывать короткий видеофрагмент (video_chunk) и аудиофон (audio_chunk).
Формирование "Чанка": Эти данные (landmark_data, video_chunk, audio_chunk, timestamp, user_id, возможно, предварительная классификация жеста, если есть на клиенте) упаковываются в "комбинированный аудио(видео)-жестовый чанк" (interaction_chunk).
Отправка:
  - **Загрузка Медиа-файлов ("чанков") в Backblaze B2:** Клиент (Frontend) взаимодействует с **FastAPI бэкендом на Koyeb**, который обрабатывает загрузку файлов в **Backblaze B2**. Это может включать генерацию presigned URL или прямую потоковую передачу через FastAPI сервис. Запросы к FastAPI защищены **Firebase Authentication**.
  - **Уведомление Firebase Cloud Functions о Загрузке:** После успешной загрузки чанка в B2, **FastAPI сервис на Koyeb** уведомляет **Firebase Cloud Functions** (например, через HTTP-запрос или Pub/Sub), передавая метаданные чанка (включая `object_key` из B2).
  - **Отправка Других Команд/Данных:** Прочие команды и данные (например, текстовые сообщения для Триа, запросы данных) отправляются напрямую из Frontend в **Firebase Cloud Functions** через HTTPS-запросы, защищенные **Firebase Authentication**.
Обработка на Бэкенде (Основная логика в Firebase Cloud Functions, специфические сервисы, как загрузка в Backblaze B2, через FastAPI на Koyeb):
Прием и Валидация (Firebase Cloud Functions):
  - HTTP-триггеры Firebase Cloud Functions получают данные запроса (или уведомления от FastAPI), валидируют их структуру и JWT токен пользователя.
Сохранение Метаданных (Firebase Cloud Functions): Firebase Cloud Function сохраняет метаданные "чанка" (включая `object_key` или URL файла в Backblaze B2, полученные от FastAPI сервиса) в базу данных **Neon.tech PostgreSQL**. Данные привязываются к `user_id`.
Передача Оркестратору Триа (Firebase Cloud Functions): Firebase Cloud Function инициирует логику Триа, передавая ей данные "чанка" и `user_id`.
Работа Ботов (модули, вызываемые из Firebase Cloud Functions или Genkit flows, управляемых Firebase):
  - GestureBot: Анализирует `landmark_data` (извлеченные на клиенте и переданные как часть метаданных) и `video_chunk` (ссылка на файл в Backblaze B2). Классифицирует жест, извлекает параметры, генерирует `gesture_embedding`.
  - AudioBot: Анализирует `audio_chunk` (ссылка на файл в Backblaze B2) для контекста или синтеза ответного звука.
  - MemoryBot (RAG): Используя эмбеддинги, осуществляет семантический поиск в базе знаний **Neon.tech PostgreSQL**.
  - LearningBot (асинхронно, например, через фоновую задачу Firebase Cloud Function или отдельный сервис, триггерящийся событием Pub/Sub или по расписанию): Получает "чанк", результат его обработки и обратную связь пользователя.
Формирование Ответа Триа (Firebase Cloud Functions / Genkit): Оркестратор Триа собирает информацию от ботов и формирует комплексный ответ. Это может быть:
  - Команды для изменения 3D-голограммы на клиенте.
  - Аудио для воспроизведения (например, ссылка на сгенерированный файл в Backblaze B2 или параметры для синтеза на клиенте).
  - Текстовый ответ для чата.
Отправка Ответа (Firebase Cloud Functions): Ответ отправляется на фронтенд как HTTP-response от вызванной Firebase Cloud Function. Для будущих реалтайм обновлений могут рассматриваться WebSockets (R&D, возможно через Firebase или другой сервис).
Реакция на Фронтенде:
Обновление Голограммы: `frontend/js/3d/rendering.js` (или `hologramRenderer.js`) получает команду и обновляет 3D-сцену.
Воспроизведение Аудио: `frontend/js/audio/audioFilePlayer.js` воспроизводит звук.
Отображение в Чате: `frontend/js/panels/chatMessages.js` отображает текстовый ответ.

## 2. Сценарий: Обучение Триа ("Триа собирает себя сама" через Эволюционный Принцип – FastAPI/Genkit)
Сбор Данных: Пользовательские взаимодействия ("чанки" в Backblaze B2, метаданные в Neon.tech PostgreSQL) и обратная связь от пользователя сохраняются с привязкой к `user_id`.
Работа LearningBot (Firebase Cloud Function Background Task / Genkit Flow / Отдельный сервис):
Анализ Эффективности: LearningBot (реализованный как фоновая задача Firebase Cloud Function, отдельный сервис, или Genkit flow, возможно, запускаемый по расписанию или Pub/Sub) периодически анализирует накопленные данные. Оценивает, какие конфигурации/модели других ботов были наиболее успешны.
Генерация и Мутация: На основе анализа, LearningBot может:
  - Мутировать параметры существующих моделей ботов (например, немного изменить пороги в GestureBot).
  - Генерировать новые варианты конфигураций ботов или даже предлагать новые эвристики/правила.
  - Использовать генетические алгоритмы для "скрещивания" успешных конфигураций и получения новых, потенциально лучших.
Отбор: Новые/мутировавшие варианты ботов тестируются (возможно, на отложенной выборке данных или в "песочнице"). Лучшие варианты (по метрикам) становятся активными или повышают свой "вес" в ансамбле.
Обновление Базы Знаний: Успешные паттерны "жест-смысл-реакция" с их векторными представлениями сохраняются/обновляются в `learned_patterns` MemoryBot-ом.
Адаптация Других Ботов: Обновленные модели/параметры от LearningBot распространяются на соответствующие инстансы ботов.

## 3. Поток Данных для "HoloGraph" (Концептуально)
*   Каждый полезный "чанк" данных от пользователя (загруженный в B2 через FastAPI сервис и обработанный Firebase Cloud Functions), который способствует обучению Триа (особенно с подтвержденной обратной связью), может генерировать пользователю токены "HoloGraph".
*   Вычислительные ресурсы, предоставленные пользователями для локальной обработки или P2P-сети, также могут вознаграждаться.
*   Смарт-контракты на блокчейне управляют эмиссией и распределением токенов.

*Устаревшая информация в этом разделе была удалена или перенесена. Актуальное описание архитектуры см. в предыдущих разделах и в `SYSTEM_INSTRUCTION_CURRENT.md`.*

## Глоссарий Ключевых Терминов, Файлов и Папок Проекта (Актуализированный)
Архитектура Проекта "Голографические Медиа"
Версия документа: 1.1 (Эта версия документа отражает переход на Firebase)
Дата последнего обновления: 09 Июля 2024 г.

### 1. Введение
Этот документ описывает высокоуровневую архитектуру, ключевые компоненты и потоки данных проекта "Голографические Медиа" (holograms.media), с акцентом на реализацию MVP в экосистеме Firebase/Google Cloud. Цель проекта – создание инновационной мультимодальной платформы для взаимодействия человека с информацией и AI через динамические 3D-аудиовизуализации ("голограммы"), а также разработка самообучающегося AI-ассистента "Триа".

### 2. Основные Концепции и Философия
This section should be read in conjunction with the foundational principles outlined in `docs/00_OVERVIEW_AND_CONTEXT/CONCEPT_AND_PHILOSOPHY.md`.
Голограмма (Hologram): Центральный элемент взаимодействия; динамическая, интерактивная 3D-аудиовизуализация данных. Для MVP рендерится с помощью Three.js/WebGL на Firebase Hosting, в перспективе – WebGPU.
Триа (Tria): AI-ядро проекта. Основная логика реализована в **Firebase Cloud Functions (Python)**. В перспективе – сеть специализированных, эволюционирующих ботов, оркеструемых с помощью Genkit (также вероятно на базе Firebase).
Комбинированный Чанк Взаимодействия (Interaction Chunk): Синхронизированный набор данных (аудио, видео, жесты, метаданные), фиксирующий одно взаимодействие пользователя с системой. Является основной "пищей" для обучения Триа. Загружается в **Backblaze B2 (через FastAPI сервис на Koyeb)**, метаданные сохраняются в Neon.tech PostgreSQL (управляется Firebase Cloud Functions).
Преодоление Симуляционно-Реального Разрыва: Обучение Триа на разнообразных реальных данных от множества пользователей для создания робастной и адаптивной AI-модели.
Новый Язык Коммуникации: Долгосрочная цель – формирование интуитивного языка, объединяющего звук, образ и жест, понятного как людям, так и AI.
HoloGraph: Децентрализованная экономическая экосистема на базе токенов (долгосрочное R&D).

### 3. Архитектура Потоков Данных и Взаимодействия

#### 3.0. Инициализация Приложения (App Initialization) - Frontend
Последовательность инициализации на стороне клиента (`frontend/js/main.js` при `DOMContentLoaded`):
1.  **Менеджер Согласия:** `initializeConsentManager()` вызывается первым для обработки согласия пользователя.
2.  **Инициализация Ядра:** `initCore()` (`core/init.js`) создает глобальный объект `state`, инициализирует базовую 3D-сцену (через `3d/sceneSetup.js`), и создает экземпляры ключевых менеджеров (`HologramRenderer`, `XRSessionManager`, `PanelManager` (из `core/ui/panelManager.js`), `MicrophoneManager`, `AudioFilePlayer`), сохраняя их в `state`.
3.  **Инициализация Основного UI:** `initializeMainUI()` (`ui/uiManager.js`) находит все основные DOM-элементы и сохраняет ссылки на них в `state.uiElements`.
4.  **Обработчик Кнопки "Start Session":** `setupStartButtonListener()` настраивает слушатель для кнопки начала сессии.
5.  **Инициализация Мультимедиа и Поток Аудиоданных для Визуализации:**
    *   Вызов `initializeMultimedia()` (`core/mediaInitializer.js`) происходит по действию пользователя (клик на "Start Session" или первое взаимодействие на мобильных).
    *   Этот модуль запрашивает доступ к камере/микрофону, создавая `MediaStream`.
    *   `AudioContext` инициализируется или возобновляется через `audioProcessing.js`.
    *   Источник аудио (микрофон через `MicrophoneManager` или файл через `AudioFilePlayer`) подключается к цепочке обработки в `audioProcessing.js`.
    *   `audioProcessing.js` загружает `waveletAnalyzer.js` как `AudioWorkletNode` ('cwt-processor').
    *   `waveletAnalyzer.js` (CwtProcessor) инициализирует WASM-модуль (`fastcwt_processor.js` и соответствующий `.wasm` файл).
    *   Аудиоданные из источника поступают в `CwtProcessor`. `CwtProcessor` передает их в WASM-функцию `encode_audio_to_hologram`.
    *   WASM-модуль выполняет CWT-анализ и возвращает обработанные данные (уровни громкости по частотным бинам и углы панорамирования) обратно в `CwtProcessor`.
    *   `CwtProcessor` отправляет эти данные через `port.postMessage` в `audioProcessing.js` (main thread).
    *   `audioProcessing.js` получает данные и сохраняет их в `state.audio.currentDbLevels` и `state.audio.currentPanAngles`.
    *   Этот процесс обеспечивает непрерывный поток обработанных аудиоданных в глобальное состояние для использования рендерером.
    *   Параллельно, видеопоток (если используется) передается в `multimodal/handsTracking.js` для анализа жестов.
6.  **Прочие Инициализации:** Запускаются инициализаторы для Firebase Auth (`core/auth.js`), менеджера промптов (`ui/promptManager.js`), менеджера версий (`ui/versionManager.js`), UI чата (`core/ui/chatUI.js` и `panels/chatMessages.js`), MediaPipe Hands (`multimodal/handsTracking.js`), распознавания речи (`audio/speechInput.js`), Tria AI (`ai/tria.js`), XR-режима (`xr/cameraManager.js`), а также общие обработчики (изменение размера, жесты Hammer.js, PWA).
7.  **Определение Платформы и Динамическая Загрузка:**
    *   `detectPlatform()` (`core/platformDetector.js`) определяет тип платформы (desktop, mobile, xr).
    *   В зависимости от платформы, динамически импортируются и инициализируются соответствующие менеджеры макета и ввода (например, `DesktopLayout`, `DesktopInput` из `platforms/desktop/`). Менеджеры макета получают `state.uiElements` для работы с DOM.
8.  **Обновление Макета и Старт Анимации:** Вызывается `updateHologramLayout()` (`ui/layoutManager.js`) для финальной настройки макета. Главный цикл анимации `animate()` (`3d/rendering.js`) запускается:
    *   В каждом кадре `animate()` читает `state.audio.currentDbLevels` и `state.audio.currentPanAngles`.
    *   Эти данные передаются в `state.hologramRendererInstance.updateVisuals()`, который обновляет 3D-колонки голограммы.
    *   Сцена рендерится.

#### 3.1. Сценарий: Взаимодействие Пользователя с Голограммой (Жест -> Звук/Визуализация)
Этот сценарий описывает основной цикл взаимодействия пользователя с системой после инициализации.
Ввод Пользователя (Клиент / Frontend на Firebase Hosting):
Источник: Жесты рук пользователя (захват MediaPipe на клиенте), голос (Web Speech API), загрузка файлов, текстовый ввод.
Захват и Обработка Аудио (для визуализации):
  - Аудио с микрофона (`audio/microphoneManager.js`) или из файла (`audio/audioFilePlayer.js`) направляется в `audio/audioProcessing.js`.
  - `audioProcessing.js` использует `AudioWorklet` (`audio/waveletAnalyzer.js`), который в свою очередь вызывает WASM-модуль (`wasm/fastcwt/fastcwt_processor.js`) для CWT-анализа.
  - Результаты анализа (уровни dB, углы панорамирования) сохраняются в `state.audio` и используются `3d/rendering.js` -> `3d/hologramRenderer.js` для обновления 3D-визуализации в каждом кадре.
Захват для "Чанка" (для отправки на бэкенд):
  - Жесты: Модуль `frontend/js/multimodal/handsTracking.js` (используя MediaPipe и видеопоток) захватывает `landmark_data`.
  - Аудио/Видео для "Чанка": Пользователь выбирает файл для загрузки, или используется аудио с микрофона/видео с камеры. (Текущая реализация `core/dataCapture.js` не ясна из проанализированных файлов, но предполагается сбор релевантных медиафрагментов).
Формирование "Чанка" (Interaction Chunk):
  - Клиентский JavaScript формирует объект с метаданными (тип данных, `timestamp`, `user_id` от Firebase Auth). Файл медиа готовится к загрузке.
Отправка на Бэкенд:
  - **Загрузка Медиа-файлов в Backblaze B2:** Клиент (Frontend) через `frontend/js/services/apiService.js` отправляет запрос (файл чанка, имя файла, тип контента) на эндпоинт **FastAPI бэкенда на Koyeb** (например, `/api/v1/upload-chunk`). Этот сервис обрабатывает загрузку файла в **Backblaze B2**. Запрос защищен **Firebase Authentication** (проверка JWT токена FastAPI сервисом).
  - **Уведомление Firebase Cloud Functions и Отправка Метаданных:** После успешной загрузки в B2, **FastAPI сервис на Koyeb** уведомляет (например, через HTTPS вызов защищенного эндпоинта Firebase Cloud Function или через Pub/Sub) основную бэкенд логику, передавая метаданные "чанка" (включая `object_key` из B2).
  - **Отправка других команд/данных:** Прочие команды (например, текстовые сообщения для Триа) отправляются напрямую из Frontend в **Firebase Cloud Functions** через HTTPS эндпоинты, защищенные Firebase Authentication.
Обработка на Сервере (Бэкенд / Основная логика в Firebase Cloud Functions; FastAPI приложение на Koyeb для специфических сервисов):
Прием и Выполнение (Firebase Cloud Functions):
  - Firebase Cloud Functions (HTTP триггеры) обрабатывают входящие запросы от Frontend или уведомления от FastAPI/Koyeb.
Валидация и Аутентификация (Firebase Cloud Functions): Каждая защищенная Cloud Function проверяет JWT токен пользователя. Pydantic модели могут использоваться для валидации данных запроса.
Сохранение Данных (Firebase Cloud Functions): Firebase Cloud Functions используют `asyncpg` (через модули в `backend/core/db/`) для сохранения/извлечения данных в/из **Neon.tech PostgreSQL**. Сохраняются метаданные чанков (ссылка/ключ на файл в B2, `user_id`, `timestamp` и др.), пользовательские жесты, состояния голограмм, история чата.
Логика Триа (реализована в Firebase Cloud Functions, может использовать LLM API):
  - Простая обработка: Триа-логика в Firebase Cloud Functions может включать прямые вызовы LLM API (Google Gemini, Mistral).
  - Модули Ботов (`backend/core/tria_bots/`): Концептуально, логика может быть структурирована с использованием модулей `ChatBot.py`, `ChunkProcessorBot.py`, `MemoryBot.py` (с RAG из Neon.tech), вызываемых внутри Firebase Cloud Functions.
  - LearningBot (асинхронно): Может быть реализован как фоновая Firebase Cloud Function (`BackgroundTasks`), отдельный сервис, или Genkit flow, триггерящийся, например, по таймеру или событию Pub/Sub.
Формирование Ответа Триа (Firebase Cloud Functions): Firebase Cloud Function формирует ответ (текст, команды для UI/голограммы).
Отправка Ответа на Фронтенд (Firebase Cloud Functions): Ответ возвращается как HTTP-response от Firebase Cloud Function.
Реакция на Клиенте (Фронтенд):
Обновление Голограммы: Модуль `frontend/js/3d/rendering.js` (или `hologramRenderer.js`) обновляет сцену.
Воспроизведение Аудио: `frontend/js/audio/audioFilePlayer.js` (если ответ содержит аудио).
Отображение в Чате: `frontend/js/panels/chatMessages.js` отображает текстовые ответы.
API для Пользовательских Данных (реализовано через FastAPI эндпоинты):
Функции для управления пользовательскими жестами, состояниями голограмм, сессиями чата и промптами доступны через защищенные HTTP-эндпоинты FastAPI. Логика этих функций находится в соответствующих модулях `backend/routers/`, которые используют общие модули из `backend/core/` (например, `crud_operations.py`) для работы с Neon.tech PostgreSQL.

#### 3.2. Сценарий: Обучение Триа и Эволюция ("Триа собирает себя сама" – FastAPI/Genkit)
(Этот раздел остается концептуально схожим, но с уточнениями по технологиям)
Непрерывный Сбор Данных: Все Interaction Chunks (метаданные в Neon.tech, файлы в Backblaze B2) и обратная связь от пользователя сохраняются с привязкой к `user_id`.
Работа LearningBot (Firebase Cloud Function Background Task / Genkit Flow / Отдельный сервис):
Анализ Эффективности: LearningBot (реализованный как фоновая задача Firebase Cloud Function, отдельный сервис, или Genkit flow, возможно, запускаемый по расписанию или Pub/Sub) периодически анализирует данные.
Эволюционный Цикл (с Genkit):
  - Генерация/Мутация: LearningBot flow предлагает изменения в параметрах других ботов/flows или генерирует новые.
  - Отбор (Валидация): Тестирование вариантов на исторических данных или через A/B тесты.
  - Обновление Базы Знаний и Моделей: Обновление данных в Neon.tech PostgreSQL и, возможно, переобучение/файн-тюнинг моделей (например, через Vertex AI).
Адаптация Других Ботов/Flows: Обновленные конфигурации распространяются.
Этот сценарий описывает, как Триа обучается и самосовершенствуется.
Непрерывный Сбор Данных: Все Interaction Chunks и явная/неявная обратная связь от пользователя (лайки/дизлайки, коррекции, время взаимодействия с определенным контентом, достижение цели) постоянно собираются и сохраняются в PostgreSQL. **Данные привязываются к `user_id`.**
Работа LearningBot (Бэкенд, фоновый/периодический процесс):
Анализ Эффективности: LearningBot регулярно анализирует накопленную базу взаимодействий и обратной связи. Он оценивает, какие конфигурации моделей, параметры, эвристики и цепочки вызовов других ботов (например, GestureBot -> MemoryBot -> AudioBot) привели к наиболее успешным результатам (высокая точность, положительная обратная связь, достижение целей пользователя).
Эволюционный Цикл:
Генерация/Мутация: На основе анализа, LearningBot проактивно:
Мутирует параметры существующих моделей ботов (например, изменяет архитектуру нейронной сети в GestureBot, подбирает веса в ансамбле моделей, корректирует пороги чувствительности).
Генерирует новые варианты конфигураций ботов, может предлагать новые типы признаков для анализа или даже новые простые эвристики/правила.
Использует генетические алгоритмы или другие методы оптимизации для "скрещивания" успешных "геномов" (конфигураций) ботов и поиска новых, более эффективных комбинаций.
Отбор (Валидация): Новые или мутировавшие варианты конфигураций ботов проходят тестирование:
На отложенной выборке исторических данных.
В "песочнице" или через A/B тестирование на небольшой группе пользователей (с их согласия).
Оцениваются по predefined метрикам (точность, скорость, ресурсоемкость, удовлетворенность пользователя).
Лучшие, наиболее эффективные варианты конфигураций ботов становятся основными (активными) или повышают свой "вес" в системе принятия решений.
Обновление Глобальной Базы Знаний: LearningBot совместно с MemoryBot обновляет общую базу знаний Триа:
Успешные и подтвержденные паттерны "ввод_пользователя -> интерпретация_триа -> реакция_триа -> результат/обратная_связь" и их векторные представления сохраняются/усиливаются.
Неудачные или устаревшие паттерны ослабляются или удаляются.
Адаптация Других Ботов: Обновленные модели, параметры или знания, сгенерированные LearningBot, распространяются на соответствующие инстансы ботов, улучшая их индивидуальную и коллективную производительность.

#### 3.3. Поток Данных и Ценности в Экосистеме "HoloGraph" (Концептуально)
Создание Ценности Пользователем:
Каждый качественный Interaction Chunk, предоставленный пользователем (особенно с явной и полезной обратной связью), который способствует обучению и улучшению Триа, регистрируется системой.
Предоставление пользователем вычислительных ресурсов (например, для локального обучения частичных моделей Триа или участия в P2P-сети для распределенных вычислений/хранения) также регистрируется.
Начисление Токенов HoloGraph:
На основе зарегистрированного вклада (данные, ресурсы, обратная связь) пользователю начисляются токены HoloGraph. Логика начисления определяется смарт-контрактами.
Использование Токенов HoloGraph:
Доступ к премиум-функциям платформы.
Участие в управлении развитием Триа и платформы (DAO – Decentralized Autonomous Organization).
Оплата вычислительных ресурсов или специализированных сервисов внутри экосистемы.
Стимулирование разработчиков за создание полезных модулей/ботов для Триа.
Самофинансирование Триа: Часть токенов может направляться на оплату облачных ресурсов для глобального обучения Триа, исследований и дальнейшего развития платформы.

### 4. Глоссарий Ключевых Терминов, Файлов и Папок
Этот раздел поддерживается в актуальном состоянии, чтобы отражать текущую структуру и терминологию проекта.
**Важно:** Все таблицы, связанные с пользовательскими данными (например, `user_gestures`, `user_holograms`, `user_chat_sessions`), теперь строго привязаны к `users.id` (из Firebase Authentication) через внешние ключи в Neon.tech PostgreSQL.

Основные Концепции:
Голограмма (Hologram): Динамическая 3D аудиовизуализация. MVP использует Three.js/WebGL. WebGPU – R&D.
Триа (Tria): AI-ассистент. Основная логика в **Firebase Cloud Functions (Python)**. Будущее – Genkit.
Комбинированный Аудио(Видео)-Жестовый Чанк (Interaction Chunk): Данные взаимодействия пользователя. Загружаются в **Backblaze B2 (через FastAPI сервис на Koyeb)**, метаданные в Neon.tech PostgreSQL (управляется Firebase Cloud Functions).
Firebase Ecosystem: Используется для Frontend Hosting, Firebase Authentication и Firebase Cloud Functions (основной бэкенд).
Neon.tech PostgreSQL + pgvector: Активная база данных.
Backblaze B2: Основное хранилище файлов для чанков.
FastAPI on Koyeb: Компонент бэкенда, развернутый на Koyeb, используется для специфических сервисов, таких как обработка загрузок в Backblaze B2.
Docker: Для контейнеризации FastAPI бэкенда на Koyeb.
Genkit: Целевой фреймворк для оркестрации AI-логики Триа (post-MVP, вероятно на Firebase).
Firebase Cloud Functions: Основная платформа для выполнения бэкенд-логики проекта.

Ключевые Директории и Файлы Проекта:
`backend/`: Содержит Python-код для Firebase Cloud Functions и FastAPI приложения.
  `backend/main.py` (или `backend/cloud_functions/`): Точка входа для Firebase Cloud Functions.
  `backend/app.py`: Точка входа FastAPI приложения (для Koyeb).
  `backend/routers/`: Модули FastAPI APIRouter (для FastAPI на Koyeb).
  `backend/core/`: Общая переиспользуемая логика (может использоваться и Cloud Functions, и FastAPI):
    `backend/core/db/`: Модули для работы с Neon.tech PostgreSQL.
    `backend/core/models/`: Pydantic модели для валидации данных API и структуры таблиц БД.
    `backend/core/services/`: (Legacy path, see `backend/services/`) Клиенты и сервисы для взаимодействия с внешними API.
    `backend/services/`: Более новая директория для сервисной логики.
      `backend/services/nlp_service.py`: Сервис для обработки естественного языка (NLP), включая анализ текста, извлечение сущностей, определение настроений и генерацию эмбеддингов.
    `backend/tria_bots/` (ранее `backend/core/tria_bots/`): Логика отдельных ботов Триа.
      `backend/tria_bots/CoordinationService.py`: Оркестрирует взаимодействие между различными ботами Триа и внешними сервисами/API. Отвечает за маршрутизацию входящих запросов/чанков, агрегацию ответов и управление состоянием взаимодействий.
      `backend/tria_bots/azr/`: Компоненты для Autonomous Zone of Regulation (AZR) в рамках LearningBot.
        `backend/tria_bots/azr/TaskGenerator.py`: Генерирует задачи для самосовершенствования системы или для проверки решений.
        `backend/tria_bots/azr/TaskSolver.py`: Пытается найти решения для задач, сгенерированных TaskGenerator.
        `backend/tria_bots/azr/azr_evaluator.py`: Оценивает предложенные TaskSolver'ом решения.
    `backend/core/tria_bots/`: (Legacy path, actual bot logic likely moved to `backend/tria_bots/`) Логика отдельных ботов Триа (вызывается из Firebase Cloud Functions).
  `backend/auth/`: Логика аутентификации (например, для FastAPI, использующая Firebase Admin SDK).
  `backend/requirements.txt`: Список Python-зависимостей для FastAPI приложения и Firebase Cloud Functions.
  `backend/tests/`: Юнит-тесты и интеграционные тесты для бэкенда.
`frontend/`: Код фронтенда, развертываемый на Firebase Hosting.
  `frontend/index.html`: Основная HTML-страница (SPA).
  `frontend/style.css`: Основные стили приложения.
  `frontend/js/`: Корневая директория для JavaScript ES6 модулей.
    `frontend/js/main.js`: Главная точка входа для фронтенда.
    `frontend/js/services/apiService.js`: Отправляет HTTP-запросы к Firebase Cloud Functions и FastAPI бэкенду на Koyeb.
    `frontend/js/services/firebaseStorageService.js` (теперь `b2StorageService.js` или аналогичный, отвечает за загрузку на B2): Управляет загрузкой файлов в Backblaze B2 через FastAPI сервис.
    `frontend/js/core/auth.js`: Интеграция с Firebase Authentication на клиенте.
`docs/`: Вся проектная документация.
`Dockerfile`: Инструкции для сборки Docker-образа FastAPI бэкенда для развертывания на Koyeb.
Корневые файлы конфигурации Firebase:
  `.firebaserc`: Определяет алиасы проектов Firebase.
  `firebase.json`: Конфигурирует развертывание Firebase Hosting и Firebase Cloud Functions.
Прочие файлы:
  `[PROJECT_CONTEXT.md] (docs/00_OVERVIEW_AND_CONTEXT/PROJECT_CONTEXT.md)`: Актуальный срез состояния проекта, его целей, структуры. Основной источник контекста для AI.
  `[tria_memory_buffer.md] (docs/99_ARCHIVE/development_logs/tria_memory_buffer.md)`: Детальный лог итераций разработки, решений и изменений. Обновляется после каждого значимого шага.

Сеть Ботов Триа (концептуально, реализуется в `backend/tria_bots/` и вызывается из Firebase Cloud Functions; в будущем оркестрируется Genkit):
AudioBot, GestureBot/VideoBot, MemoryBot, LearningBot, CoordinationService (Оркестратор), NLPService (как вспомогательный сервис).
Компоненты AZR (TaskGenerator, TaskSolver, AZREvaluator) являются частью расширенной функциональности LearningBot, обеспечивая его способность к саморегуляции и самосовершенствованию.

### 5. Блок-схема Верхнего Уровня
*(Примечание: Mermaid-диаграмма ниже была обновлена для отражения гибридной архитектуры.)*

**Пояснения к обновленной блок-схеме:**
1.  **Пользователь** взаимодействует с **Frontend (Firebase Hosting)**.
2.  Frontend использует **Firebase Authentication** для аутентификации пользователя (получение JWT токена).
3.  Для загрузки медиа-"чанков" (аудио, видео), Frontend:
    a.  Отправляет запрос на загрузку чанка (файл, метаданные) на **FastAPI сервис на Koyeb (для B2)**. Этот сервис обрабатывает загрузку файла в **Backblaze B2**.
    b.  **FastAPI сервис на Koyeb** уведомляет **Firebase Cloud Functions (Основной Бэкенд)** об успешной загрузке, передавая метаданные и `object_key` из B2.
4.  Для выполнения другой бизнес-логики (например, текстовые команды Триа, запросы данных), Frontend делает HTTPS-запросы напрямую к **Firebase Cloud Functions (Основной Бэкенд)**, передавая JWT токен для авторизации.
5.  **Firebase Cloud Functions (Основной Бэкенд)**:
    *   Проверяют JWT токен пользователя с помощью Firebase Admin SDK.
    *   Обрабатывают входящие HTTP-запросы и уведомления.
    *   Инкапсулируют или вызывают логику **Триа-Ботов** (модули в `backend/core/tria_bots/`).
    *   Взаимодействуют с **Neon.tech PostgreSQL + pgvector** для выполнения CRUD-операций, хранения метаданных, пользовательских данных и обеспечения RAG-функциональности.
    *   Обращаются к **Внешним LLM API** (например, Google Gemini, Mistral API) для генерации текста, анализа и других AI-задач.
    *   В будущем, эта логика может быть интегрирована или оркестрирована с помощью **Genkit** flows (вероятно, также на Firebase).
6.  **FastAPI сервис на Koyeb (для B2)**:
    *   Принимает запросы на загрузку файлов от Frontend.
    *   Обрабатывает загрузку файлов в **Backblaze B2**.
    *   Уведомляет Firebase Cloud Functions о результате загрузки.
    *   Также проверяет JWT токен для авторизации запросов на загрузку.
7.  Firebase Cloud Functions возвращают HTTP-ответы (например, JSON) на Frontend.
8.  Frontend соответствующим образом обновляет UI, визуализацию голограммы, воспроизводит аудио и т.д.
9.  **HoloGraph (Блокчейн)** и связанные с ним P2P-механизмы остаются долгосрочным R&D направлением.

*Примечание по инициализации Frontend:* Инициализация приложения включает определение платформы (`detectPlatform`), динамическую загрузку платформо-зависимых модулей управления макетом и вводом, и отложенную инициализацию мультимедиа (`initializeMultimedia`), которая активируется по первому действию пользователя (клик на "Start Session" или первое взаимодействие на мобильных устройствах).

```mermaid
graph LR
    A[Пользователь] -->|Жесты, Голос, Файлы, Команды| B(Frontend на Firebase Hosting)

    subgraph Google Cloud / Firebase
        FB_AUTH[Firebase Authentication]
        FCF[Firebase Cloud Functions (Основной Бэкенд)]
    end

    subgraph External Storage
        B2_STORAGE[Backblaze B2]
    end

    subgraph Koyeb Hosting
        FASTAPI_KOYEB[FastAPI на Koyeb (для B2)]
    end

    subgraph Backend Logic & Data
        TRIA_LOGIC{Логика Триа}
        DB[(Neon.tech PostgreSQL + pgvector)]
    end

    LLM_API[External LLM APIs (Gemini, Mistral)]
    HG[HoloGraph (Блокчейн) - R&D]

    B -- Аутентификация (JWT) --> FB_AUTH

    B -- "1. Запрос на загрузку чанка (HTTPS с JWT)" --> FASTAPI_KOYEB
    FASTAPI_KOYEB -- "2. Обработка загрузки" --> B2_STORAGE
    FASTAPI_KOYEB -- "3. Уведомление о загрузке (событие/HTTPS)" --> FCF

    B -- "API Запросы (Триа, данные и т.д. HTTPS с JWT)" --> FCF

    FCF -- "Проверка токена с Firebase Admin" --> FB_AUTH
    FCF -- "Данные/Команды" --> TRIA_LOGIC
    TRIA_LOGIC -- "CRUD, RAG" --> DB
    TRIA_LOGIC -- "Запросы" --> LLM_API
    LLM_API -- "Ответы" --> TRIA_LOGIC
    DB -- "Данные" --> TRIA_LOGIC
    TRIA_LOGIC -- "Результат" --> FCF
    FCF -- "HTTP Response" --> B
    B -- "Обновление UI/Голограммы" --> A
```

(Цель этого глоссария – дать простое и понятное объяснение основных компонентов проекта, чтобы у всех участников, включая AI и НейроКодера, было единое понимание. Список будет пополняться по мере развития проекта.)
Основные Концепции:
Голограмма (Hologram): Динамическая трехмерная аудиовизуализация, являющаяся основным способом представления информации и взаимодействия в проекте. Генерируется и управляется с помощью WebGPU.
Триа (Tria): AI-ассистент и ядро проекта. Представляет собой сеть специализированных ботов, которые анализируют пользовательский ввод, генерируют реакции и обучаются на взаимодействиях. Цель Триа – "собрать себя сама" через эволюционные принципы.
Комбинированный Аудио(Видео)-Жестовый Чанк (Interaction Chunk): Основная единица данных, фиксирующая взаимодействие пользователя с системой. Включает синхронизированные аудиоданные, видеоданные (для анализа жестов и контекста), данные о распознанных жестах (координаты, параметры) и метаданные (время, ID пользователя, обратная связь). Используется для обучения Триа.
Симуляционно-Реальный Разрыв (Sim-to-Real Gap): Проблема переноса моделей AI, обученных в симуляции, в реальный мир. В нашем проекте – это разрыв между уникальными данными каждого пользователя и общей, но адаптивной моделью Триа. Преодолевается через обучение на разнообразных "чанках" от множества пользователей.
Новый Язык Коммуникации: Долгосрочная цель проекта – создание интуитивного языка, объединяющего звук, образ и жест, понятного как людям, так и AI.
HoloGraph: Рабочее название для децентрализованной экономической системы проекта. Предполагает использование токенов для вознаграждения пользователей за предоставление качественных "чанков" данных и вычислительных ресурсов, а также для управления развитием Триа и платформы (через DAO). Название "HoloGraph" подчеркивает связь с голограммами и графовой структурой знаний/взаимодействий.
Ключевые Директории и Файлы Проекта:
`backend/`: Содержит весь Python-код бэкенда.
`backend/app.py`: Основной файл FastAPI приложения (для Koyeb), инициализирует приложение, подключает роутеры, управляет жизненным циклом.
`backend/tria_bots/`: Директория для модулей, реализующих отдельных ботов сети Триа (AudioBot, GestureBot, MemoryBot, LearningBot, CoordinationService).
`backend/db/schema.sql`: Определяет структуру базы данных PostgreSQL, включая таблицы `users`, `user_chat_sessions`, `chat_history`, `user_gestures`, `user_holograms`, `user_prompt_versions` и другие.
`backend/db/crud_operations.py`: Содержит функции для выполнения операций чтения, записи, обновления и удаления данных в PostgreSQL.
`backend/auth/security.py`: Функции для хэширования паролей, создания и проверки JWT токенов, зависимости для получения текущего пользователя.
`backend/routers/auth.py`: API эндпоинты для регистрации и аутентификации пользователей (`/auth/register`, `/auth/token`).
`backend/routers/gestures.py`: API эндпоинты для управления пользовательскими жестами (`/users/me/gestures`).
`backend/routers/holograms.py`: API эндпоинты для управления пользовательскими сохраненными состояниями голограмм (`/users/me/holograms`).
`backend/routers/chat_sessions.py`: API эндпоинты для управления сессиями чата и сообщениями (`/users/me/chat_sessions`).
`backend/routers/prompts.py`: API эндпоинты для управления версиями пользовательских промптов (`/users/me/prompts`).
`backend/models/`: Директория с Pydantic моделями, определяющими структуру данных для API запросов/ответов и для взаимодействия с базой данных.
    `backend/models/user_models.py`: Модели для пользователей (`UserCreate`, `UserPublic`, `UserInDB`).
    `backend/models/auth_models.py`: Модели для аутентификации (`Token`, `TokenData`).
    `backend/models/gesture_models.py`: Модели для жестов.
    `backend/models/hologram_models.py`: Модели для состояний голограмм.
    `backend/models/chat_models.py`: Модели для чат-сессий и сообщений.
    `backend/models/prompt_models.py`: Модели для версий промптов.
`backend/services/`: Директория для различных сервисов, используемых бэкендом.
    `backend/services/nlp_service.py`: Сервис для обработки естественного языка (NLP), предоставляющий функции анализа текста, извлечения сущностей, определения тональности и т.д. Используется другими ботами или сервисами для понимания текстовых данных.
`backend/requirements.txt`: Список Python-зависимостей бэкенда.
`backend/tests/`: Юнит-тесты и интеграционные тесты для бэкенда.
`backend/.venv/`: (Рекомендуемое место) Виртуальное окружение Python для бэкенда.
`frontend/`: Содержит весь код фронтенда (HTML, CSS, JavaScript).
`frontend/index.html`: Единственная HTML-страница приложения (SPA).
`frontend/style.css`: Основные стили приложения.
`frontend/js/`: Корневая директория для всех JavaScript ES6 модулей.
`frontend/js/main.js`: Главная точка входа для фронтенда; импортирует и инициализирует все остальные JS модули.
`frontend/js/services/apiService.js`: Отправляет HTTP-запросы к Firebase Cloud Functions и FastAPI бэкенду на Koyeb.
`frontend/js/services/firebaseStorageService.js` (теперь `b2StorageService.js` или аналогичный, отвечает за загрузку на B2): Управляет загрузкой файлов в Backblaze B2 через FastAPI сервис.
`frontend/js/core/auth.js`: Интеграция с Firebase Authentication на клиенте.
`docs/`: Вся проектная документация.
`Dockerfile`: Инструкции для сборки Docker-образа FastAPI бэкенда для развертывания на Koyeb.
Корневые файлы конфигурации Firebase:
  `.firebaserc`: Определяет алиасы проектов Firebase.
  `firebase.json`: Конфигурирует развертывание Firebase Hosting и Firebase Cloud Functions.
Прочие файлы:
  `[PROJECT_CONTEXT.md] (docs/00_OVERVIEW_AND_CONTEXT/PROJECT_CONTEXT.md)`: Актуальный срез состояния проекта, его целей, структуры. Основной источник контекста для AI.
  `[tria_memory_buffer.md] (docs/99_ARCHIVE/development_logs/tria_memory_buffer.md)`: Детальный лог итераций разработки, решений и изменений. Обновляется после каждого значимого шага.
Сеть Ботов Триа (концептуально, реализуется в `backend/tria_bots/` и вызывается из Firebase Cloud Functions; в будущем оркестрируется Genkit):
AudioBot, GestureBot/VideoBot, MemoryBot, LearningBot, CoordinationService (Оркестратор), NLPService (как вспомогательный сервис).
Компоненты AZR (TaskGenerator, TaskSolver, AZREvaluator) являются частью расширенной функциональности LearningBot, обеспечивая его способность к саморегуляции и самосовершенствованию.

Блок-схема Верхнего Уровня (Концептуальная)
```mermaid
graph LR
    A[Пользователь] -->|Жест, Голос, Контекст, Текст| B(Frontend)
    B -->|Interaction Chunk, Commands (HTTP/WebSocket)| C{Backend (FastAPI & Firebase Cloud Functions)}

    subgraph Backend Core Logic
        D[CoordinationService / Tria Orchestrator]
        NLP[NLPService]
        E[GestureBot / VideoBot]
        F[AudioBot]
        G[MemoryBot (RAG)]
        H[LearningBot (Эволюция, Анализ, AZR)]
    end

    C -->|Данные чанка, Команды| D
    D --> E
    D --> F
    D --> NLP
    E --> G
    F --> G
    NLP --> G # NLP может использовать MemoryBot для контекста
    D --> H
    H -- Обновления --> E
    H -- Обновления --> F
    H -- Обновления --> G
    D --> I[Ответ Триа (Команды визуализации, Аудио, Текст)]
    I --> C
    C -->|Обновление UI, Голограммы, Звук| B
    B --> A

    J[База Данных PostgreSQL + pgvector]
    G <--> J
    H <--> J

    K[HoloGraph (Блокчейн) - R&D]
    L[Данные о вкладе пользователя] --> K
    M[Вычислительные ресурсы] --> K
    K -->|Вознаграждение| A
    K -->|Управление| H

    %% Note: AZR components (TaskGenerator, TaskSolver, AZREvaluator) are part of LearningBot's internal mechanism.
    %% NLPService is a supporting service that can be called by CoordinationService or other bots.
```
Этот расширенный раздел должен дать гораздо лучшее понимание как статической структуры, так и динамики работы проекта. Его нужно будет поддерживать в актуальном состоянии.

Пояснения к блок-схеме:
Пользователь взаимодействует с Frontend.
Frontend формирует Interaction Chunk и отправляет на Backend.
Backend (FastAPI) передает чанк Координатору Триа.
Координатор распределяет задачи между GestureBot, AudioBot.
Эти боты могут обращаться к MemoryBot для получения контекста из Базы Данных PostgreSQL (pgvector).
LearningBot асинхронно анализирует данные из БД и обратную связь, обновляя другие боты (эволюция).
Координатор формирует Ответ Триа и отправляет его на Frontend.
Frontend обновляет UI, Голограмму, воспроизводит звук.
Система HoloGraph (Блокчейн) учитывает вклад пользователя (данные, ресурсы) и может управлять развитием Триа.

## 6. Future Directions and Long-Term Vision Integration (Placeholder)

This section is intended to outline near-to-mid-term architectural evolution and how foundational principles for longer-term goals (such as those discussed in the "Visionary Architecture & Foundational Scaffolding" research) will be integrated.

*(Detailed content for this section will be developed based on ongoing research, strategic decisions, and concepts previously outlined in `FUTUREARCHITECTURE.MD`. Note: `FUTUREARCHITECTURE.MD` was not found during the latest consolidation effort, so its specific inputs could not be directly merged at this time. This section will be updated as these concepts are further refined and prioritized.)*

Key areas for future consideration include:
-   **NetHoloGlyph Protocol:** Maturing the protocol for rich, real-time holographic communication.
-   **Advanced Gestural Programming:** Evolving `GestureBot` and interaction models for more complex "sculpted" logic.
-   **"Liquid Code" Concepts:** Exploring how code embeddings could allow Tria to understand and evolve its own logic.
-   **Tria's Self-Evolution (AZR):** Implementing robust Absolute Zero Reasoning cycles for autonomous capability growth.
-   **HoloGraph Tokenomics:** Detailing data structures and system interactions for the token-based ecosystem.
