# Архитектура Потоков Данных и Взаимодействия Проекта "Голографические Медиа"

## 1. Сценарий: Взаимодействие Пользователя с Голограммой (Жест -> Звук/Визуализация)
Ввод Пользователя (Frontend):
Жест: Пользователь совершает жест рукой перед камерой.
Захват: frontend/js/multimodal/handsTracking.js (используя MediaPipe) захватывает координаты ключевых точек руки (landmark_data).
Видео/Аудио Контекст: Одновременно frontend/js/core/dataCapture.js (или аналогичный модуль) может захватывать короткий видеофрагмент (video_chunk) и аудиофон (audio_chunk).
Формирование "Чанка": Эти данные (landmark_data, video_chunk, audio_chunk, timestamp, user_id, возможно, предварительная классификация жеста, если есть на клиенте) упаковываются в "комбинированный аудио(видео)-жестовый чанк" (interaction_chunk).
Отправка:
  - **Загрузка Медиа-файлов ("чанков") в Cloudflare R2:** Клиент (Frontend) взаимодействует с **FastAPI бэкендом на Koyeb**, который обрабатывает загрузку файлов в **Cloudflare R2**. Это может включать генерацию presigned URL или прямую потоковую передачу через FastAPI сервис. Запросы к FastAPI защищены **Firebase Authentication**.
  - **Обработка Загрузки и Запуск Логики Триа (FastAPI на Koyeb):** После успешной загрузки чанка в R2, **FastAPI сервис на Koyeb** получает уведомление (например, от клиента или внутреннего триггера после загрузки), сохраняет метаданные чанка (включая `object_key` из R2) в **Neon.tech PostgreSQL** и инициирует основную логику обработки Триа.
  - **Отправка Других Команд/Данных (FastAPI на Koyeb):** Прочие команды и данные (например, текстовые сообщения для Триа, запросы данных) также отправляются из Frontend напрямую на эндпоинты **FastAPI на Koyeb**, защищенные **Firebase Authentication**. Firebase Cloud Functions могут использоваться для специфических событий Firebase или как вспомогательные обработчики, если это необходимо (например, для уведомлений или задач, тесно интегрированных с другими сервисами Firebase, не являющихся частью основного потока Триа).
Обработка на Бэкенде (Основная логика AI Триа на FastAPI (Koyeb); Firebase Cloud Functions для вспомогательных задач):
Прием и Валидация (FastAPI на Koyeb):
  - Эндпоинты FastAPI получают данные запроса, валидируют их структуру (например, с помощью Pydantic) и JWT токен пользователя (проверяется с помощью Firebase Admin SDK).
Сохранение Метаданных (FastAPI на Koyeb): FastAPI сервис сохраняет метаданные "чанка" (включая `object_key` или URL файла в Cloudflare R2) в базу данных **Neon.tech PostgreSQL**. Данные привязываются к `user_id`.
Передача Оркестратору Триа и Работа Ботов (FastAPI на Koyeb): FastAPI сервис содержит или вызывает оркестратор Триа, который управляет взаимодействием ботов (GestureBot, AudioBot, MemoryBot, LearningBot). Эти боты, реализованные как часть FastAPI приложения или отдельные модули, выполняют анализ данных (например, `landmark_data` из запроса, `video_chunk`/`audio_chunk` по ссылке из Cloudflare R2) и другие задачи.
  - GestureBot: Анализирует `landmark_data` и `video_chunk`.
  - AudioBot: Анализирует `audio_chunk`.
  - MemoryBot (RAG): Осуществляет семантический поиск в **Neon.tech PostgreSQL**.
  - LearningBot (может быть асинхронной задачей, управляемой FastAPI, или отдельным сервисом, триггерящимся событиями из основной системы): Получает "чанк", результат его обработки и обратную связь пользователя.
Формирование Ответа Триа (FastAPI на Koyeb / Genkit): Оркестратор Триа в FastAPI собирает информацию от ботов и формирует комплексный ответ. Это может быть:
  - Команды для изменения 3D-голограммы на клиенте.
  - Аудио для воспроизведения (например, ссылка на сгенерированный файл в Cloudflare R2 или параметры для синтеза на клиенте).
  - Текстовый ответ для чата.
Отправка Ответа (FastAPI на Koyeb): Ответ отправляется на фронтенд как HTTP-response от FastAPI эндпоинта. Для будущих реалтайм обновлений могут рассматриваться WebSockets, управляемые FastAPI.
Реакция на Фронтенде:
Обновление Голограммы: `frontend/js/3d/rendering.js` (или `hologramRenderer.js`) получает команду и обновляет 3D-сцену.
Воспроизведение Аудио: `frontend/js/audio/audioFilePlayer.js` воспроизводит звук.
Отображение в Чате: `frontend/js/panels/chatMessages.js` отображает текстовый ответ.

## 2. Сценарий: Обучение Триа ("Триа собирает себя сама" через Эволюционный Принцип – FastAPI/Genkit)
Сбор Данных: Пользовательские взаимодействия ("чанки" в Cloudflare R2, метаданные в Neon.tech PostgreSQL) и обратная связь от пользователя сохраняются с привязкой к `user_id` (через FastAPI бэкенд).
Работа LearningBot (FastAPI / Отдельный сервис / Genkit Flow):
Анализ Эффективности: LearningBot (реализованный как часть FastAPI бэкенда, например, через фоновые задачи Celery/ARQ, или как отдельный сервис, или Genkit flow, управляемый FastAPI) периодически анализирует накопленные данные. Оценивает, какие конфигурации/модели других ботов были наиболее успешны.
Генерация и Мутация: На основе анализа, LearningBot может:
  - Мутировать параметры существующих моделей ботов (например, немного изменить пороги в GestureBot).
  - Генерировать новые варианты конфигураций ботов или даже предлагать новые эвристики/правила.
  - Использовать генетические алгоритмы для "скрещивания" успешных конфигураций и получения новых, потенциально лучших.
Отбор: Новые/мутировавшие варианты ботов тестируются (возможно, на отложенной выборке данных или в "песочнице"). Лучшие варианты (по метрикам) становятся активными или повышают свой "вес" в ансамбле.
Обновление Базы Знаний: Успешные паттерны "жест-смысл-реакция" с их векторными представлениями сохраняются/обновляются в `learned_patterns` MemoryBot-ом.
Адаптация Других Ботов: Обновленные модели/параметры от LearningBot распространяются на соответствующие инстансы ботов.

## 3. Поток Данных для "HoloGraph" (Концептуально)
*   Каждый полезный "чанк" данных от пользователя (загруженный в R2 и обработанный через FastAPI сервис на Koyeb), который способствует обучению Триа (особенно с подтвержденной обратной связью), может генерировать пользователю токены "HoloGraph".
*   Вычислительные ресурсы, предоставленные пользователями для локальной обработки или P2P-сети, также могут вознаграждаться.
*   Смарт-контракты на блокчейне управляют эмиссией и распределением токенов.

*Устаревшая информация в этом разделе была удалена или перенесена. Актуальное описание архитектуры см. в предыдущих разделах и в `SYSTEM_INSTRUCTION_CURRENT.md`.*

## Глоссарий Ключевых Терминов, Файлов и Папок Проекта (Актуализированный)
Архитектура Проекта "Голографические Медиа"
Версия документа: 1.1 (Эта версия документа отражает переход на Firebase)
Дата последнего обновления: July 30, 2024

### 1. Введение
Этот документ описывает высокоуровневую архитектуру, ключевые компоненты и потоки данных проекта "Голографические Медиа" (holograms.media), с акцентом на реализацию MVP в экосистеме Firebase/Google Cloud. Цель проекта – создание инновационной мультимодальной платформы для взаимодействия человека с информацией и AI через динамические 3D-аудиовизуализации ("голограммы"), а также разработка самообучающегося AI-ассистента "Триа".

### 2. Основные Концепции и Философия
This section should be read in conjunction with the foundational principles outlined in `docs/00_OVERVIEW_AND_CONTEXT/CONCEPT_AND_PHILOSOPHY.md`.
Голограмма (Hologram): Центральный элемент взаимодействия; динамическая, интерактивная 3D-аудиовизуализация данных. Для MVP рендерится с помощью Three.js/WebGL на Firebase Hosting, в перспективе – WebGPU.
Триа (Tria): AI-ядро проекта. **Основа логики AI "Триа", включая оркестрацию ботов и генерацию ответов, размещается на FastAPI-эндпоинтах, работающих на Koyeb.** В перспективе – сеть специализированных, эволюционирующих ботов, оркеструемых с помощью Genkit, интегрированного в FastAPI бэкенд.
Комбинированный Чанк Взаимодействия (Interaction Chunk): Синхронизированный набор данных (аудио, видео, жесты, метаданные), фиксирующий одно взаимодействие пользователя с системой. Является основной "пищей" для обучения Триа. Загружается в **Cloudflare R2 (через FastAPI сервис на Koyeb)**, метаданные сохраняются в Neon.tech PostgreSQL (управляется FastAPI сервисом).
Преодоление Симуляционно-Реального Разрыва: Обучение Триа на разнообразных реальных данных от множества пользователей для создания робастной и адаптивной AI-модели.
Новый Язык Коммуникации: Долгосрочная цель – формирование интуитивного языка, объединяющего звук, образ и жест, понятного как людям, так и AI.
HoloGraph: Децентрализованная экономическая экосистема на базе токенов (долгосрочное R&D).

### 3. Архитектура Потоков Данных и Взаимодействия

#### 3.0. Инициализация Приложения (App Initialization) - Frontend
Последовательность инициализации на стороне клиента (`frontend/js/main.js` при `DOMContentLoaded`):
1.  **Менеджер Согласия:** `initializeConsentManager()` вызывается первым для обработки согласия пользователя.
2.  **Инициализация Ядра:** `initCore()` (`core/init.js`) создает глобальный объект `state`, инициализирует базовую 3D-сцену (через `3d/sceneSetup.js`), и создает экземпляры ключевых менеджеров (`HologramRenderer`, `XRSessionManager`, `PanelManager` (из `core/ui/panelManager.js`), `MicrophoneManager`, `AudioFilePlayer`), сохраняя их в `state`.
3.  **Инициализация Основного UI:** `initializeMainUI()` (`ui/uiManager.js`) находит все основные DOM-элементы и сохраняет ссылки на них в `state.uiElements`.
4.  **Обработчик Кнопки "Start Session":** `setupStartButtonListener()` настраивает слушатель для кнопки начала сессии.
5.  **Инициализация Мультимедиа и Поток Аудиоданных для Визуализации:**
    *   Вызов `initializeMultimedia()` (`core/mediaInitializer.js`) происходит по действию пользователя (клик на "Start Session" или первое взаимодействие на мобильных).
    *   Этот модуль запрашивает доступ к камере/микрофону, создавая `MediaStream`.
    *   `AudioContext` инициализируется или возобновляется через `audioProcessing.js`.
    *   Источник аудио (микрофон через `MicrophoneManager` или файл через `AudioFilePlayer`) подключается к цепочке обработки в `audioProcessing.js`.
    *   `audioProcessing.js` загружает `waveletAnalyzer.js` как `AudioWorkletNode` ('cwt-processor').
    *   `waveletAnalyzer.js` (CwtProcessor) инициализирует WASM-модуль (`fastcwt_processor.js` и соответствующий `.wasm` файл).
    *   Аудиоданные из источника поступают в `CwtProcessor`. `CwtProcessor` передает их в WASM-функцию `encode_audio_to_hologram`.
    *   WASM-модуль выполняет CWT-анализ и возвращает обработанные данные (уровни громкости по частотным бинам и углы панорамирования) обратно в `CwtProcessor`.
    *   `CwtProcessor` отправляет эти данные через `port.postMessage` в `audioProcessing.js` (main thread).
    *   `audioProcessing.js` получает данные и сохраняет их в `state.audio.currentDbLevels` и `state.audio.currentPanAngles`.
    *   Этот процесс обеспечивает непрерывный поток обработанных аудиоданных в глобальное состояние для использования рендерером.
    *   Параллельно, видеопоток (если используется) передается в `multimodal/handsTracking.js` для анализа жестов.
6.  **Прочие Инициализации:** Запускаются инициализаторы для Firebase Auth (`core/auth.js`), менеджера промптов (`ui/promptManager.js`), менеджера версий (`ui/versionManager.js`), UI чата (`core/ui/chatUI.js` и `panels/chatMessages.js`), MediaPipe Hands (`multimodal/handsTracking.js`), распознавания речи (`audio/speechInput.js`), Tria AI (`ai/tria.js`), XR-режима (`xr/cameraManager.js`), а также общие обработчики (изменение размера, жесты Hammer.js, PWA).
7.  **Определение Платформы и Динамическая Загрузка:**
    *   `detectPlatform()` (`core/platformDetector.js`) определяет тип платформы (desktop, mobile, xr).
    *   В зависимости от платформы, динамически импортируются и инициализируются соответствующие менеджеры макета и ввода (например, `DesktopLayout`, `DesktopInput` из `platforms/desktop/`). Менеджеры макета получают `state.uiElements` для работы с DOM.
8.  **Обновление Макета и Старт Анимации:** Вызывается `updateHologramLayout()` (`ui/layoutManager.js`) для финальной настройки макета. Главный цикл анимации `animate()` (`3d/rendering.js`) запускается:
    *   В каждом кадре `animate()` читает `state.audio.currentDbLevels` и `state.audio.currentPanAngles`.
    *   Эти данные передаются в `state.hologramRendererInstance.updateVisuals()`, который обновляет 3D-колонки голограммы.
    *   Сцена рендерится.

#### 3.1. Сценарий: Взаимодействие Пользователя с Голограммой (Жест -> Звук/Визуализация)
Этот сценарий описывает основной цикл взаимодействия пользователя с системой после инициализации.
Ввод Пользователя (Клиент / Frontend на Firebase Hosting):
Источник: Жесты рук пользователя (захват MediaPipe на клиенте), голос (Web Speech API), загрузка файлов, текстовый ввод.
Захват и Обработка Аудио (для визуализации):
  - Аудио с микрофона (`audio/microphoneManager.js`) или из файла (`audio/audioFilePlayer.js`) направляется в `audio/audioProcessing.js`.
  - `audioProcessing.js` использует `AudioWorklet` (`audio/waveletAnalyzer.js`), который в свою очередь вызывает WASM-модуль (`wasm/fastcwt/fastcwt_processor.js`) для CWT-анализа.
  - Результаты анализа (уровни dB, углы панорамирования) сохраняются в `state.audio` и используются `3d/rendering.js` -> `3d/hologramRenderer.js` для обновления 3D-визуализации в каждом кадре.
Захват для "Чанка" (для отправки на бэкенд):
  - Жесты: Модуль `frontend/js/multimodal/handsTracking.js` (используя MediaPipe и видеопоток) захватывает `landmark_data`.
  - Аудио/Видео для "Чанка": Пользователь выбирает файл для загрузки, или используется аудио с микрофона/видео с камеры. (Текущая реализация `core/dataCapture.js` не ясна из проанализированных файлов, но предполагается сбор релевантных медиафрагментов).
Формирование "Чанка" (Interaction Chunk):
  - Клиентский JavaScript формирует объект с метаданными (тип данных, `timestamp`, `user_id` от Firebase Auth). Файл медиа готовится к загрузке.
Отправка на Бэкенд:
  - **Загрузка Медиа-файлов в Cloudflare R2:** Клиент (Frontend) через `frontend/js/services/apiService.js` отправляет запрос (файл чанка, имя файла, тип контента) на эндпоинт **FastAPI бэкенда на Koyeb** (например, `/api/v1/upload-chunk`). Этот сервис обрабатывает загрузку файла в **Cloudflare R2**. Запрос защищен **Firebase Authentication** (проверка JWT токена FastAPI сервисом).
  - **Обработка Загрузки и Запуск Логики Триа (FastAPI на Koyeb):** После успешной загрузки чанка в R2, **FastAPI сервис на Koyeb** получает уведомление (например, от клиента или внутреннего триггера после загрузки), сохраняет метаданные чанка (включая `object_key` из R2) в **Neon.tech PostgreSQL** и инициирует основную логику обработки Триа.
  - **Отправка Других Команд/Данных (FastAPI на Koyeb):** Прочие команды и данные (например, текстовые сообщения для Триа, запросы данных) также отправляются из Frontend напрямую на эндпоинты **FastAPI на Koyeb**, защищенные **Firebase Authentication**. Firebase Cloud Functions могут использоваться для специфических событий Firebase или как вспомогательные обработчики, если это необходимо (например, для уведомлений или задач, тесно интегрированных с другими сервисами Firebase, не являющихся частью основного потока Триа).
Обработка на Сервере (Бэкенд / Основная логика AI Триа на FastAPI (Koyeb); Firebase Cloud Functions для вспомогательных задач):
Прием и Выполнение (FastAPI на Koyeb):
  - Эндпоинты FastAPI получают данные запроса, валидируют их структуру (например, с помощью Pydantic) и JWT токен пользователя (проверяется с помощью Firebase Admin SDK).
Валидация и Аутентификация (FastAPI на Koyeb): FastAPI проверяет JWT токен пользователя (с Firebase Admin SDK) и валидирует данные запроса (Pydantic).
Сохранение Данных (FastAPI на Koyeb): FastAPI сервис использует `asyncpg` (через модули в `backend/core/db/`) для сохранения/извлечения данных в/из **Neon.tech PostgreSQL**. Сохраняются метаданные чанков (ссылка/ключ на файл в R2, `user_id`, `timestamp` и др.), пользовательские жесты, состояния голограмм, история чата.
Логика Триа (реализована в FastAPI на Koyeb, может использовать LLM API):
  - Оркестрация: FastAPI управляет основной логикой Триа, включая вызовы LLM API (Google Gemini, Mistral).
  - Модули Ботов (`backend/tria_bots/`): Логика ботов (ChatBot, ChunkProcessorBot, MemoryBot с RAG) интегрирована и вызывается в рамках FastAPI приложения.
  - LearningBot (асинхронно): Может быть реализован как фоновая задача в FastAPI (Celery, ARQ), отдельный сервис, или Genkit flow, управляемый из FastAPI.
Формирование Ответа Триа (FastAPI на Koyeb): FastAPI формирует ответ (текст, команды для UI/голограммы).
Отправка Ответа на Фронтенд (FastAPI на Koyeb): Ответ возвращается как HTTP-response от FastAPI.
Реакция на Клиенте (Фронтенд):
Обновление Голограммы: Модуль `frontend/js/3d/rendering.js` (или `hologramRenderer.js`) обновляет сцену.
Воспроизведение Аудио: `frontend/js/audio/audioFilePlayer.js` (если ответ содержит аудио).
Отображение в Чате: `frontend/js/panels/chatMessages.js` отображает текстовые ответы.
API для Пользовательских Данных (реализовано через FastAPI эндпоинты):
Функции для управления пользовательскими жестами, состояниями голограмм, сессиями чата и промптами доступны через защищенные HTTP-эндпоинты FastAPI. Логика этих функций находится в соответствующих модулях `backend/routers/`, которые используют общие модули из `backend/core/` (например, `crud_operations.py`) для работы с Neon.tech PostgreSQL.

#### 3.2. Сценарий: Обучение Триа и Эволюция ("Триа собирает себя сама" – FastAPI/Genkit)
(Этот раздел остается концептуально схожим, но с уточнением, что основная логика и оркестрация LearningBot теперь тяготеют к FastAPI/Koyeb бэкенду)
Непрерывный Сбор Данных: Все Interaction Chunks (метаданные в Neon.tech, файлы в Cloudflare R2) и обратная связь от пользователя сохраняются с привязкой к `user_id` через FastAPI бэкенд.
Работа LearningBot (FastAPI / Отдельный сервис / Genkit Flow):
Анализ Эффективности: LearningBot (реализованный как часть FastAPI бэкенда, например, через фоновые задачи, или как отдельный сервис, или Genkit flow, управляемый FastAPI) периодически анализирует данные.
Эволюционный Цикл (с Genkit, интегрированным в FastAPI):
  - Генерация/Мутация: LearningBot flow предлагает изменения в параметрах других ботов/flows или генерирует новые.
  - Отбор (Валидация): Тестирование вариантов на исторических данных или через A/B тесты.
  - Обновление Базы Знаний и Моделей: Обновление данных в Neon.tech PostgreSQL и, возможно, переобучение/файн-тюнинг моделей (например, через Vertex AI).
Адаптация Других Ботов/Flows: Обновленные конфигурации распространяются.
Этот сценарий описывает, как Триа обучается и самосовершенствуется.
Непрерывный Сбор Данных: Все Interaction Chunks и явная/неявная обратная связь от пользователя (лайки/дизлайки, коррекции, время взаимодействия с определенным контентом, достижение цели) постоянно собираются и сохраняются в PostgreSQL. **Данные привязываются к `user_id`.**
Работа LearningBot (Бэкенд, фоновый/периодический процесс):
Анализ Эффективности: LearningBot регулярно анализирует накопленную базу взаимодействий и обратной связи. Он оценивает, какие конфигурации моделей, параметры, эвристики и цепочки вызовов других ботов (например, GestureBot -> MemoryBot -> AudioBot) привели к наиболее успешным результатам (высокая точность, положительная обратная связь, достижение целей пользователя).
Эволюционный Цикл:
Генерация/Мутация: На основе анализа, LearningBot проактивно:
Мутирует параметры существующих моделей ботов (например, изменяет архитектуру нейронной сети в GestureBot, подбирает веса в ансамбле моделей, корректирует пороги чувствительности).
Генерирует новые варианты конфигураций ботов, может предлагать новые типы признаков для анализа или даже новые простые эвристики/правила.
Использует генетические алгоритмы или другие методы оптимизации для "скрещивания" успешных "геномов" (конфигураций) ботов и поиска новых, более эффективных комбинаций.
Отбор (Валидация): Новые или мутировавшие варианты конфигураций ботов проходят тестирование:
На отложенной выборке исторических данных.
В "песочнице" или через A/B тестирование на небольшой группе пользователей (с их согласия).
Оцениваются по predefined метрикам (точность, скорость, ресурсоемкость, удовлетворенность пользователя).
Лучшие, наиболее эффективные варианты конфигураций ботов становятся основными (активными) или повышают свой "вес" в системе принятия решений.
Обновление Глобальной Базы Знаний: LearningBot совместно с MemoryBot обновляет общую базу знаний Триа:
Успешные и подтвержденные паттерны "ввод_пользователя -> интерпретация_триа -> реакция_триа -> результат/обратная_связь" и их векторные представления сохраняются/усиливаются.
Неудачные или устаревшие паттерны ослабляются или удаляются.
Адаптация Других Ботов: Обновленные модели, параметры или знания, сгенерированные LearningBot, распространяются на соответствующие инстансы ботов, улучшая их индивидуальную и коллективную производительность.

#### 3.3. Поток Данных и Ценности в Экосистеме "HoloGraph" (Концептуально)
Создание Ценности Пользователем:
Каждый качественный Interaction Chunk, предоставленный пользователем (особенно с явной и полезной обратной связью), который способствует обучению и улучшению Триа, регистрируется системой.
Предоставление пользователем вычислительных ресурсов (например, для локального обучения частичных моделей Триа или участия в P2P-сети для распределенных вычислений/хранения) также регистрируется.
Начисление Токенов HoloGraph:
На основе зарегистрированного вклада (данные, ресурсы, обратная связь) пользователю начисляются токены HoloGraph. Логика начисления определяется смарт-контрактами.
Использование Токенов HoloGraph:
Доступ к премиум-функциям платформы.
Участие в управлении развитием Триа и платформы (DAO – Decentralized Autonomous Organization).
Оплата вычислительных ресурсов или специализированных сервисов внутри экосистемы.
Стимулирование разработчиков за создание полезных модулей/ботов для Триа.
Самофинансирование Триа: Часть токенов может направляться на оплату облачных ресурсов для глобального обучения Триа, исследований и дальнейшего развития платформы.

### 4. Глоссарий Ключевых Терминов, Файлов и Папок
Этот раздел поддерживается в актуальном состоянии, чтобы отражать текущую структуру и терминологию проекта.
**Важно:** Все таблицы, связанные с пользовательскими данными (например, `user_gestures`, `user_holograms`, `user_chat_sessions`), теперь строго привязаны к `users.id` (из Firebase Authentication) через внешние ключи в Neon.tech PostgreSQL.

Основные Концепции:
Голограмма (Hologram): Динамическая 3D аудиовизуализация. MVP использует Three.js/WebGL. WebGPU – R&D.
Триа (Tria): AI-ассистент и ядро проекта. **Основа логики AI "Триа", включая оркестрацию ботов и генерацию ответов, размещается на FastAPI-эндпоинтах, работающих на Koyeb.** В перспективе – сеть специализированных, эволюционирующих ботов, оркеструемых с помощью Genkit, интегрированного в FastAPI бэкенд.
Комбинированный Аудио(Видео)-Жестовый Чанк (Interaction Chunk): Данные взаимодействия пользователя. Загружаются в **Cloudflare R2 (через FastAPI сервис на Koyeb)**, метаданные сохраняются в Neon.tech PostgreSQL (также управляется FastAPI сервисом).
Firebase Ecosystem: Используется для Frontend Hosting и Firebase Authentication. Firebase Cloud Functions играют вспомогательную роль.
Neon.tech PostgreSQL + pgvector: Активная база данных.
Cloudflare R2: Основное хранилище файлов для чанков.
FastAPI on Koyeb: **Основной бэкенд-компонент, развернутый на Koyeb. Отвечает за API, бизнес-логику, обработку данных, взаимодействие с R2 и Neon.tech, а также за выполнение основной AI-логики Триа.**
Docker: Для контейнеризации FastAPI бэкенда на Koyeb.
Genkit: Целевой фреймворк для оркестрации AI-логики Триа (post-MVP, будет интегрирован с FastAPI бэкендом).
Firebase Cloud Functions: **Используются для вспомогательных задач и специфических триггеров Firebase (например, Auth triggers), а также могут быть вызваны FastAPI бэкендом для выполнения изолированных подзадач. Основная API-логика и AI-вычисления Триа выполняются на FastAPI (Koyeb).**

Ключевые Директории и Файлы Проекта:
`backend/`: Содержит Python-код для FastAPI приложения и, возможно, для вспомогательных Firebase Cloud Functions.
  `backend/main.py` (или `backend/cloud_functions/`): Точка входа для Firebase Cloud Functions (если используются для вспомогательных задач).
  `backend/app.py`: Точка входа FastAPI приложения (для Koyeb), где реализуется основная API и AI-логика Триа.
  `backend/routers/`: Модули FastAPI APIRouter (для FastAPI на Koyeb).
  `backend/core/`: Общая переиспользуемая логика (используется преимущественно FastAPI):
    `backend/core/db/`: Модули для работы с Neon.tech PostgreSQL.
    `backend/core/models/`: Pydantic модели для валидации данных API и структуры таблиц БД.
    `backend/services/`: Сервисная логика, включая взаимодействие с внешними API и Cloudflare R2.
      `backend/services/nlp_service.py`: Сервис для обработки естественного языка (NLP).
      `backend/services/storage_service.py` (предполагаемое имя): Сервис для работы с Cloudflare R2.
    `backend/tria_bots/`: Логика отдельных ботов Триа, интегрированная в FastAPI приложение.
      `backend/tria_bots/CoordinationService.py`: Оркестрирует взаимодействие между различными ботами Триа и внешними сервисами/API в рамках FastAPI.
      `backend/tria_bots/azr/`: Компоненты для Autonomous Zone of Regulation (AZR) в рамках LearningBot, работающие в контексте FastAPI.
  `backend/auth/`: Логика аутентификации для FastAPI, использующая Firebase Admin SDK для проверки токенов.
  `backend/requirements.txt`: Список Python-зависимостей для FastAPI приложения (и FCF, если есть).
  `backend/tests/`: Юнит-тесты и интеграционные тесты для FastAPI бэкенда.
`frontend/`: Код фронтенда, развертываемый на Firebase Hosting.
  `frontend/index.html`: Основная HTML-страница (SPA).
  `frontend/style.css`: Основные стили приложения.
  `frontend/js/`: Корневая директория для JavaScript ES6 модулей.
    `frontend/js/main.js`: Главная точка входа для фронтенда.
    `frontend/js/services/apiService.js`: Отправляет HTTP-запросы к FastAPI бэкенду на Koyeb.
    `frontend/js/services/r2StorageService.js` (или аналогичный, отвечает за загрузку на R2): Может содержать логику для получения presigned URL от FastAPI бэкенда для прямой загрузки в Cloudflare R2, или взаимодействовать с `apiService.js`.
    `frontend/js/core/auth.js`: Интеграция с Firebase Authentication на клиенте.
`docs/`: Вся проектная документация.
`Dockerfile`: Инструкции для сборки Docker-образа FastAPI бэкенда для развертывания на Koyeb.
Корневые файлы конфигурации Firebase:
  `.firebaserc`: Определяет алиасы проектов Firebase.
  `firebase.json`: Конфигурирует развертывание Firebase Hosting и, возможно, вспомогательных Firebase Cloud Functions.
Прочие файлы:
  `[PROJECT_CONTEXT.md] (docs/00_OVERVIEW_AND_CONTEXT/PROJECT_CONTEXT.md)`: Актуальный срез состояния проекта, его целей, структуры. Основной источник контекста для AI.
  `[tria_memory_buffer.md] (docs/99_ARCHIVE/development_logs/tria_memory_buffer.md)`: Детальный лог итераций разработки, решений и изменений. Обновляется после каждого значимого шага.

Сеть Ботов Триа (концептуально, реализуется в `backend/tria_bots/` и оркестрируется FastAPI на Koyeb; в будущем может использоваться Genkit, интегрированный с FastAPI):
AudioBot, GestureBot/VideoBot, MemoryBot, LearningBot, CoordinationService (Оркестратор), NLPService (как вспомогательный сервис).
Компоненты AZR (TaskGenerator, TaskSolver, AZREvaluator) являются частью расширенной функциональности LearningBot, обеспечивая его способность к саморегуляции и самосовершенствованию в рамках FastAPI бэкенда.

### 5. Блок-схема Верхнего Уровня
*(Примечание: Mermaid-диаграмма ниже была обновлена для отражения гибридной архитектуры.)*

**Пояснения к обновленной блок-схеме:**
1.  **Пользователь** взаимодействует с **Frontend (Firebase Hosting)**.
2.  Frontend использует **Firebase Authentication** для аутентификации пользователя (получение JWT токена).
3.  Для загрузки медиа-"чанков" (аудио, видео) и выполнения команд Триа, Frontend отправляет HTTPS-запросы (с JWT токеном) на **FastAPI сервис на Koyeb**.
4.  **FastAPI сервис на Koyeb (Основной Бэкенд):**
    *   Проверяет JWT токен пользователя (с помощью Firebase Admin SDK).
    *   Обрабатывает запросы на загрузку файлов, сохраняя их в **Cloudflare R2**.
    *   Сохраняет метаданные и другую информацию в **Neon.tech PostgreSQL + pgvector**.
    *   Инкапсулирует и выполняет основную логику **Триа-Ботов** (модули в `backend/tria_bots/`).
    *   Взаимодействует с **Внешними LLM API** (например, Google Gemini, Mistral API) для генерации текста, анализа и других AI-задач.
    *   В будущем, эта логика может быть интегрирована или оркестрирована с помощью **Genkit** flows, работающих в окружении FastAPI.
    *   Возвращает HTTP-ответы (например, JSON с результатами обработки Триа, командами для UI) на Frontend.
5.  **Firebase Cloud Functions (Вспомогательный Бэкенд):**
    *   Могут использоваться для выполнения специфических задач, инициируемых событиями Firebase (например, Firebase Auth triggers - создание профиля пользователя в БД после регистрации).
    *   Могут вызываться FastAPI бэкендом для выполнения изолированных, вспомогательных операций, если это целесообразно.
    *   Не являются основным местом выполнения логики Триа или обработки API запросов от пользователя.
6.  Frontend соответствующим образом обновляет UI, визуализацию голограммы, воспроизводит аудио и т.д. на основе ответов от FastAPI.
7.  **HoloGraph (Блокчейн)** и связанные с ним P2P-механизмы остаются долгосрочным R&D направлением.

*Примечание по инициализации Frontend:* Инициализация приложения включает определение платформы (`detectPlatform`), динамическую загрузку платформо-зависимых модулей управления макетом и вводом, и отложенную инициализацию мультимедиа (`initializeMultimedia`), которая активируется по первому действию пользователя (клик на "Start Session" или первое взаимодействие на мобильных устройствах).

```mermaid
graph LR
    A[Пользователь] -->|Жесты, Голос, Файлы, Команды (HTTPS с JWT)| B(Frontend на Firebase Hosting)

    subgraph Google Cloud / Firebase
        FB_AUTH[Firebase Authentication]
        FCF[Firebase Cloud Functions (Вспомогательные задачи)]
    end

    subgraph External Storage
        R2_STORAGE[Cloudflare R2 Storage]
    end

    subgraph Koyeb Hosting
        FASTAPI_KOYEB[FastAPI on Koyeb (Основной Бэкенд API + Логика Триа)]
    end

    subgraph Backend Logic & Data (внутри FastAPI/Koyeb)
        TRIA_LOGIC{Tria Logic Engine / Bots}
        DB[(Neon.tech PostgreSQL + pgvector)]
    end

    LLM_API[External LLM APIs (Gemini, Mistral)]
    HG[HoloGraph (Blockchain) - R&D]

    B -- Аутентификация (JWT) --> FB_AUTH

    B -- "Запросы API и загрузка чанков (HTTPS с JWT)" --> FASTAPI_KOYEB
    FASTAPI_KOYEB -- "Загрузка файлов" --> R2_STORAGE
    FASTAPI_KOYEB -- "Проверка токена Firebase Admin" --> FB_AUTH
    FASTAPI_KOYEB -- "Данные/Команды" --> TRIA_LOGIC
    TRIA_LOGIC -- "CRUD, RAG" --> DB
    TRIA_LOGIC -- "Запросы" --> LLM_API
    LLM_API -- "Ответы" --> TRIA_LOGIC
    DB -- "Данные" --> TRIA_LOGIC
    TRIA_LOGIC -- "Результат" --> FASTAPI_KOYEB
    FASTAPI_KOYEB -- "HTTP Response" --> B

    FCF -- "Триггеры Firebase (напр., Auth)" --> DB # Например, создание профиля пользователя
    FCF -.-> FASTAPI_KOYEB # FCF могут вызывать FastAPI для сложных операций, если необходимо

    B -- "Обновление UI/Голограммы" --> A
```

(Цель этого глоссария – дать простое и понятное объяснение основных компонентов проекта, чтобы у всех участников, включая AI и НейроКодера, было единое понимание. Список будет пополняться по мере развития проекта.)
Основные Концепции:
Голограмма (Hologram): Динамическая трехмерная аудиовизуализация, являющаяся основным способом представления информации и взаимодействия в проекте. Генерируется и управляется с помощью WebGPU.
Триа (Tria): AI-ассистент и ядро проекта. Представляет собой сеть специализированных ботов, которые анализируют пользовательский ввод, генерируют реакции и обучаются на взаимодействиях (основная логика на FastAPI/Koyeb). Цель Триа – "собрать себя сама" через эволюционные принципы.
Комбинированный Аудио(Видео)-Жестовый Чанк (Interaction Chunk): Основная единица данных, фиксирующая взаимодействие пользователя с системой. Включает синхронизированные аудиоданные, видеоданные (для анализа жестов и контекста), данные о распознанных жестах (координаты, параметры) и метаданные (время, ID пользователя, обратная связь). Используется для обучения Триа.
Симуляционно-Реальный Разрыв (Sim-to-Real Gap): Проблема переноса моделей AI, обученных в симуляции, в реальный мир. В нашем проекте – это разрыв между уникальными данными каждого пользователя и общей, но адаптивной моделью Триа. Преодолевается через обучение на разнообразных "чанках" от множества пользователей.
Новый Язык Коммуникации: Долгосрочная цель проекта – создание интуитивного языка, объединяющего звук, образ и жест, понятного как людям, так и AI.
HoloGraph: Рабочее название для децентрализованной экономической системы проекта. Предполагает использование токенов для вознаграждения пользователей за предоставление качественных "чанков" данных и вычислительных ресурсов, а также для управления развитием Триа и платформы (через DAO). Название "HoloGraph" подчеркивает связь с голограммами и графовой структурой знаний/взаимодействий.
Ключевые Директории и Файлы Проекта:
`backend/`: Содержит весь Python-код бэкенда.
`backend/app.py`: Основной файл FastAPI приложения (для Koyeb), инициализирует приложение, подключает роутеры, управляет жизненным циклом.
`backend/tria_bots/`: Директория для модулей, реализующих отдельных ботов сети Триа (AudioBot, GestureBot, MemoryBot, LearningBot, CoordinationService).
`backend/db/schema.sql`: Определяет структуру базы данных PostgreSQL, включая таблицы `users`, `user_chat_sessions`, `chat_history`, `user_gestures`, `user_holograms`, `user_prompt_versions` и другие.
`backend/db/crud_operations.py`: Содержит функции для выполнения операций чтения, записи, обновления и удаления данных в PostgreSQL.
`backend/auth/security.py`: Функции для хэширования паролей, создания и проверки JWT токенов, зависимости для получения текущего пользователя.
`backend/routers/auth.py`: API эндпоинты для регистрации и аутентификации пользователей (`/auth/register`, `/auth/token`).
`backend/routers/gestures.py`: API эндпоинты для управления пользовательскими жестами (`/users/me/gestures`).
`backend/routers/holograms.py`: API эндпоинты для управления пользовательскими сохраненными состояниями голограмм (`/users/me/holograms`).
`backend/routers/chat_sessions.py`: API эндпоинты для управления сессиями чата и сообщениями (`/users/me/chat_sessions`).
`backend/routers/prompts.py`: API эндпоинты для управления версиями пользовательских промптов (`/users/me/prompts`).
`backend/models/`: Директория с Pydantic моделями, определяющими структуру данных для API запросов/ответов и для взаимодействия с базой данных.
    `backend/models/user_models.py`: Модели для пользователей (`UserCreate`, `UserPublic`, `UserInDB`).
    `backend/models/auth_models.py`: Модели для аутентификации (`Token`, `TokenData`).
    `backend/models/gesture_models.py`: Модели для жестов.
    `backend/models/hologram_models.py`: Модели для состояний голограмм.
    `backend/models/chat_models.py`: Модели для чат-сессий и сообщений.
    `backend/models/prompt_models.py`: Модели для версий промптов.
`backend/services/`: Директория для различных сервисов, используемых бэкендом.
    `backend/services/nlp_service.py`: Сервис для обработки естественного языка (NLP), предоставляющий функции анализа текста, извлечения сущностей, определения тональности и т.д. Используется другими ботами или сервисами для понимания текстовых данных.
`backend/requirements.txt`: Список Python-зависимостей бэкенда.
`backend/tests/`: Юнит-тесты и интеграционные тесты для бэкенда.
`backend/.venv/`: (Рекомендуемое место) Виртуальное окружение Python для бэкенда.
`frontend/`: Содержит весь код фронтенда (HTML, CSS, JavaScript).
`frontend/index.html`: Единственная HTML-страница приложения (SPA).
`frontend/style.css`: Основные стили приложения.
`frontend/js/`: Корневая директория для всех JavaScript ES6 модулей.
`frontend/js/main.js`: Главная точка входа для фронтенда; импортирует и инициализирует все остальные JS модули.
`frontend/js/services/apiService.js`: Отправляет HTTP-запросы к Firebase Cloud Functions и FastAPI бэкенду на Koyeb.
    `frontend/js/services/r2StorageService.js` (or similar, responsible for R2 uploads): Manages file uploads to Cloudflare R2 via the FastAPI service.
    `frontend/js/core/auth.js`: Client-side Firebase Authentication integration.
`docs/`: All project documentation.
`Dockerfile`: Инструкции для сборки Docker-образа FastAPI бэкенда для развертывания на Koyeb.
Корневые файлы конфигурации Firebase:
  `.firebaserc`: Определяет алиасы проектов Firebase.
  `firebase.json`: Конфигурирует развертывание Firebase Hosting и Firebase Cloud Functions.
Прочие файлы:
  `[PROJECT_CONTEXT.md] (docs/00_OVERVIEW_AND_CONTEXT/PROJECT_CONTEXT.md)`: Актуальный срез состояния проекта, его целей, структуры. Основной источник контекста для AI.
  `[tria_memory_buffer.md] (docs/99_ARCHIVE/development_logs/tria_memory_buffer.md)`: Детальный лог итераций разработки, решений и изменений. Обновляется после каждого значимого шага.
Сеть Ботов Триа (концептуально, реализуется в `backend/tria_bots/` и вызывается из Firebase Cloud Functions; в будущем оркестрируется Genkit):
AudioBot, GestureBot/VideoBot, MemoryBot, LearningBot, CoordinationService (Оркестратор), NLPService (как вспомогательный сервис).
Компоненты AZR (TaskGenerator, TaskSolver, AZREvaluator) являются частью расширенной функциональности LearningBot, обеспечивая его способность к саморегуляции и самосовершенствованию.

Блок-схема Верхнего Уровня (Концептуальная)
```mermaid
graph LR
    A[Пользователь] -->|Жест, Голос, Контекст, Текст| B(Frontend)
    B -->|Interaction Chunk, Commands (HTTP/WebSocket)| C{Backend (FastAPI & Firebase Cloud Functions)}

    subgraph Backend Core Logic
        D[CoordinationService / Tria Orchestrator]
        NLP[NLPService]
        E[GestureBot / VideoBot]
        F[AudioBot]
        G[MemoryBot (RAG)]
        H[LearningBot (Эволюция, Анализ, AZR)]
    end

    C -->|Данные чанка, Команды| D
    D --> E
    D --> F
    D --> NLP
    E --> G
    F --> G
    NLP --> G # NLP может использовать MemoryBot для контекста
    D --> H
    H -- Обновления --> E
    H -- Обновления --> F
    H -- Обновления --> G
    D --> I[Ответ Триа (Команды визуализации, Аудио, Текст)]
    I --> C
    C -->|Обновление UI, Голограммы, Звук| B
    B --> A

    J[База Данных PostgreSQL + pgvector]
    G <--> J
    H <--> J

    K[HoloGraph (Блокчейн) - R&D]
    L[Данные о вкладе пользователя] --> K
    M[Вычислительные ресурсы] --> K
    K -->|Вознаграждение| A
    K -->|Управление| H

    %% Note: AZR components (TaskGenerator, TaskSolver, AZREvaluator) are part of LearningBot's internal mechanism.
    %% NLPService is a supporting service that can be called by CoordinationService or other bots.
```
Этот расширенный раздел должен дать гораздо лучшее понимание как статической структуры, так и динамики работы проекта. Его нужно будет поддерживать в актуальном состоянии.

Пояснения к блок-схеме:
Пользователь взаимодействует с Frontend.
Frontend формирует Interaction Chunk и другие запросы и отправляет их на основной Backend (FastAPI на Koyeb).
FastAPI бэкенд обрабатывает запросы, взаимодействует с Cloudflare R2 для файлов, Neon.tech PostgreSQL для данных, и управляет логикой Триа (включая ботов и вызовы LLM).
Firebase Cloud Functions используются для вспомогательных задач, часто инициируемых событиями Firebase.
FastAPI возвращает ответ на Frontend.
Frontend обновляет UI, Голограмму, воспроизводит звук.
Система HoloGraph (Блокчейн) учитывает вклад пользователя (данные, ресурсы) и может управлять развитием Триа.

## 6. Future Directions and Long-Term Vision Integration (Placeholder)

This section is intended to outline near-to-mid-term architectural evolution and how foundational principles for longer-term goals (such as those discussed in the "Visionary Architecture & Foundational Scaffolding" research) will be integrated.

*(Detailed content for this section will be developed based on ongoing research, strategic decisions, and concepts previously outlined in `FUTUREARCHITECTURE.MD`. Note: `FUTUREARCHITECTURE.MD` was not found during the latest consolidation effort, so its specific inputs could not be directly merged at this time. This section will be updated as these concepts are further refined and prioritized.)*

Key areas for future consideration include:
-   **NetHoloGlyph Protocol:** Maturing the protocol for rich, real-time holographic communication.
-   **Advanced Gestural Programming:** Evolving `GestureBot` and interaction models for more complex "sculpted" logic.
-   **"Liquid Code" Concepts:** Exploring how code embeddings could allow Tria to understand and evolve its own logic.
-   **Tria's Self-Evolution (AZR):** Implementing robust Absolute Zero Reasoning cycles for autonomous capability growth.
-   **HoloGraph Tokenomics:** Detailing data structures and system interactions for the token-based ecosystem.
