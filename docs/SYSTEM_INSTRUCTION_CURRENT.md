[Начало Системной Инструкции]

**Системная Инструкция Проекта "Holographic Media Interface"**

**Версия Документа:** 36.0
**Дата Актуализации:** 2024-07-26

**Содержание:**
1.  Общее Описание и Цели Системы
2.  Архитектура Системы
    *   2.1. Обзор Компонентов
    *   2.2. Frontend Архитектура
    *   2.3. Backend Архитектура (FastAPI на Koyeb)
    *   2.4. База Данных (Neon.tech PostgreSQL)
    *   2.5. Хранилище Файлов (Cloudflare R2)
    *   2.6. AI Оркестрация (Genkit)
    *   2.7. Аутентификация (Firebase Authentication)
3.  Ключевые Потоки Данных
    *   3.1. Инициализация Приложения
    *   3.2. Взаимодействие Пользователя (Жест -> Результат)
    *   3.3. Загрузка "Чанка" Взаимодействия
    *   3.4. Обработка "Чанка" и Логика Триа
    *   3.5. Обучение Триа (Эволюционный Принцип)
4.  Основные Директивы для Разработки и Взаимодействия
5.  Взаимодействие с Инструментами
6.  Процедура Обновления Данной Системной Инструкции
7.  Протокол Архитектурной Целостности и Стратегического Исполнения (Версия 3.0)
8.  Глоссарий

---

**1. Общее Описание и Цели Системы**

Проект "Holographic Media Interface" (holograms.media) нацелен на создание инновационной мультимодальной платформы для взаимодействия человека с информацией и AI через динамические 3D-аудиовизуализации ("голограммы"). Центральным элементом является самообучающийся AI-ассистент "Триа", который эволюционирует на основе взаимодействий с пользователем. Система стремится разработать новый интуитивный язык коммуникации, объединяющий звук, образ и жест.

**Основные Директивы (Из Версии 35.0):**
*   **Приоритет Задач:** Всегда следовать приоритетам, указанным в текущем задании. При возникновении конфликтов или неясностей, запрашивать уточнения.
*   **Качество Кода:** Писать чистый, эффективный и хорошо документированный код. Придерживаться установленных стандартов кодирования.
*   **Безопасность:** Уделять первостепенное внимание вопросам безопасности на всех этапах разработки.
*   **Тестирование:** Тщательно тестировать все изменения перед их отправкой. Автоматизированные тесты – обязательны.
*   **Отчетность:** Регулярно и подробно отчитываться о проделанной работе, возникших проблемах и достигнутых результатах. Использовать `submit_subtask_report`.

---

**2. Архитектура Системы**

**2.1. Обзор Компонентов**

Система состоит из следующих ключевых компонентов:
*   **Frontend:** Веб-приложение на Firebase Hosting, использующее Vite для сборки и разработки. Реализует пользовательский интерфейс, 3D-визуализацию (Three.js/WebGL), захват и предварительную обработку пользовательского ввода (жесты, аудио). Управляется через npm.
*   **Backend (FastAPI на Koyeb):** Основной сервер приложений, написанный на Python с использованием FastAPI и развернутый на платформе Koyeb. Обрабатывает API-запросы, управляет бизнес-логикой, взаимодействует с базой данных и хранилищем файлов, оркеструет AI-логику.
*   **База Данных (Neon.tech PostgreSQL):** Облачная база данных PostgreSQL с расширением pgvector для хранения структурированных данных, метаданных чанков, пользовательских данных и векторных представлений.
*   **Хранилище Файлов (Cloudflare R2):** S3-совместимое объектное хранилище для "чанков" взаимодействия (аудио, видео, данные жестов).
*   **AI Оркестрация (Genkit):** Фреймворк от Google для построения и запуска AI-потоков (flows). Интегрирован с FastAPI бэкендом и используется для управления сложными AI-задачами и взаимодействием с LLM.
*   **Аутентификация (Firebase Authentication):** Обеспечивает безопасную аутентификацию пользователей и управление ими. JWT токены, выданные Firebase Auth, проверяются на бэкенде.
*   **Вспомогательные Функции (Firebase Cloud Functions):** Могут использоваться для выполнения специфических задач, инициируемых событиями Firebase (например, Auth триггеры) или для изолированных вспомогательных операций.

**2.2. Frontend Архитектура (Vite + NPM)**

**2.2.1. Сборка и Зависимости:**

*   **Сборщик:** Основой фронтенда является Vite. Он используется для запуска локального dev-сервера (`npm run dev`) и для создания оптимизированной производственной сборки (`npm run build`).
*   **Конфигурация (`vite.config.js`):** Ключевые параметры конфигурации, находящейся в корне проекта:
    *   `root: 'frontend'`: Указывает Vite, что все исходные файлы фронтенда лежат в папке `/frontend`.
    *   `build: { outDir: '../dist' }`: Указывает, что результат сборки нужно класть в папку `/dist` в корне проекта. Это важно для CI/CD и деплоя на Firebase.
    *   `resolve.alias`: Настроен псевдоним `'three/addons/': path.resolve(__dirname, 'node_modules/three/examples/jsm/')` для корректного разрешения путей к дополнительным модулям `three.js`.
*   **Зависимости (`package.json`):** Все внешние библиотеки (`three`, `@tweenjs/tween.js`, `@mediapipe/...` и т.д.) управляются исключительно через npm. Использование `<script type="importmap">` и прямое подключение библиотек через CDN-скрипты в `index.html` признано устаревшей и нестабильной практикой, приводящей к конфликтам, и не должно использоваться.

**2.2.2. Точка Входа и Инициализация (`main.js`):**

*   Основной точкой входа является `frontend/js/main.js`.
*   После события `DOMContentLoaded` запускается асинхронная инициализация, разделенная на два этапа:
    *   `initCore()`: Создание и настройка фундаментальных компонентов (WebGLRenderer, сцена, камера, менеджеры), которые записываются в глобальный объект `state`.
    *   `startFullApplication()`: Запускается после получения согласия пользователя. Инициализирует мультимедиа (MediaPipe, AudioContext) и запускает цикл рендеринга.

**2.2.3. 3D-Рендеринг (`/3d`):**

*   **Рендерер:** По состоянию на v36, для максимальной стабильности и совместимости в различных окружениях (включая headless-браузеры AI-агентов) используется `WebGLRenderer`. Миграция на `WebGPURenderer` является целью, но требует отдельного исследования совместимости со всем стеком.
*   **Цикл Рендеринга (`rendering.js`):** Функция `animation` вызывается через `renderer.setAnimationLoop()`. Для рендеринга используется стандартный метод `renderer.render(scene, camera)`.
*   **Голограмма (`hologramRenderer.js`):** Метод `updateVisuals` отвечает за динамическое изменение геометрии на основе данных из `state.audio`.

**2.2.4. Мультимодальный Ввод (`/multimodal`):**

*   **MediaPipe Hands (`handsTracking.js`):** Интеграция с `@mediapipe/hands` происходит через ES6-импорты. Для решения проблемы с загрузкой бинарных моделей (`.tflite`, `.wasm`) в среде Vite, инстанс `Hands` обязательно должен инициализироваться с опцией `locateFile`, указывающей на CDN:
    `locateFile: (file) => \`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/\${file}\``
*   **Жесты (`gestures.js`):** Библиотека Hammer.js для обработки жестов также подключается как npm-модуль (`import Hammer from 'hammerjs';`).

**2.3. Backend Архитектура (FastAPI на Koyeb)**

*   **Платформа:** Развернут на Koyeb с использованием Docker. `Dockerfile` находится в корне проекта.
*   **Фреймворк:** FastAPI (Python).
*   **Основные Задачи:**
    *   **API Эндпоинты:** Предоставление RESTful API для фронтенда (`backend/routers/`). Используются Pydantic модели (`backend/models/`) для валидации данных.
    *   **Аутентификация и Авторизация:** Проверка JWT токенов, полученных от Firebase Authentication, с использованием Firebase Admin SDK (`backend/auth/`).
    *   **Взаимодействие с Базой Данных:** CRUD-операции с Neon.tech PostgreSQL с использованием `asyncpg` (через `backend/core/db/` и `backend/db/crud_operations.py`).
    *   **Взаимодействие с Хранилищем Файлов:** Обработка загрузки "чанков" взаимодействия в Cloudflare R2. Используется `boto3` для взаимодействия с S3-совместимым API R2. Клиент `boto3` инициализируется при старте приложения (`backend/app.py` или `backend/core/services/storage_service.py`).
    *   **Оркестрация AI Логики (Триа):** Управление и выполнение AI-потоков, разработанных с использованием Genkit. FastAPI вызывает Genkit flows для обработки запросов, требующих AI-обработки (например, анализ чанков, генерация ответов).
    *   **Бизнес-Логика:** Реализация основной серверной логики приложения.
*   **Структура Проекта (Бэкенд):**
    *   `backend/app.py`: Точка входа FastAPI приложения, инициализация.
    *   `backend/routers/`: API-роутеры для различных ресурсов.
    *   `backend/core/`: Общая логика (база данных, модели, сервисы).
    *   `backend/services/`: Сервисы для специфических задач (например, `storage_service.py` для R2).
    *   `backend/flows/` (или аналогичная): Местоположение Genkit flows.
    *   `backend/tria_bots/`: Может содержать вспомогательную логику для Genkit или устаревшие компоненты ботов.
    *   `backend/requirements.txt`: Зависимости Python.

**2.4. База Данных (Neon.tech PostgreSQL)**

*   **Тип:** Облачная реляционная база данных PostgreSQL.
*   **Расширения:** Используется `pgvector` для хранения векторных представлений (embeddings), что важно для семантического поиска и работы MemoryBot (RAG).
*   **Данные:** Хранит метаданные "чанков", пользовательские данные (профили, настройки, жесты), историю чатов, состояния голограмм, обученные паттерны Триа.
*   **Взаимодействие:** FastAPI бэкенд использует `asyncpg` для асинхронного взаимодействия с базой данных.

**2.5. Хранилище Файлов (Cloudflare R2)**

*   **Тип:** S3-совместимое объектное хранилище.
*   **Назначение:** Основное хранилище для медиа-файлов "чанков" взаимодействия (аудио, видео).
*   **Взаимодействие:** FastAPI бэкенд управляет загрузкой файлов в R2. Эндпоинт загрузки (например, в `backend/routers/interaction_chunks.py`) принимает файл от клиента, генерирует уникальное имя и ключ объекта (например, `user_chunks/{user_id}/{unique_filename_with_uuid}`), и использует `boto3` для загрузки файла в бакет R2.
*   **Конфигурация:** Переменные окружения (`R2_ENDPOINT_URL`, `R2_ACCESS_KEY_ID`, `R2_SECRET_ACCESS_KEY`, `R2_BUCKET_NAME`) используются для настройки клиента `boto3`.

**2.6. AI Оркестрация (Genkit)**

*   **Роль:** Основной инструмент для разработки, выполнения и управления AI-потоками (flows) в проекте "Триа".
*   **Интеграция:** Genkit flows интегрированы и вызываются из FastAPI бэкенда. Это позволяет FastAPI обрабатывать входящие HTTP-запросы, аутентифицировать пользователя, подготавливать данные, а затем передавать управление Genkit flow для выполнения сложных AI-операций.
*   **Задачи:** Анализ "чанков" взаимодействия, управление диалогами (ChatBot), работа с базой знаний (MemoryBot с RAG), координация различных AI-моделей и эвристик, реализация логики LearningBot.
*   **Взаимодействие с LLM:** Genkit flows могут вызывать внешние LLM API (например, Google Gemini, Mistral) для генерации текста, анализа и других AI-задач.

**2.7. Аутентификация (Firebase Authentication)**

*   **Клиентская Сторона:** Frontend использует Firebase SDK для аутентификации пользователей (логин, регистрация). После успешной аутентификации клиент получает JWT токен.
*   **Серверная Сторона (FastAPI):** FastAPI бэкенд получает JWT токен в заголовках авторизации (`Authorization: Bearer <token>`). Firebase Admin SDK используется для проверки и декодирования токена, извлечения `user_id` и других данных пользователя. Это обеспечивает защищенный доступ к API эндпоинтам.
*   **Примечание для разработки:** Для корректной работы OAuth-провайдеров в средах с динамическими URL (например, Cloud Workstations, cloudflared tunnel), необходимо добавлять временный домен в список "Authorized domains" в консоли Firebase.

---

**3. Ключевые Потоки Данных**

**3.1. Инициализация Приложения (Frontend)**
Подробно описана в `docs/RU/Architecture/SystemDescription.MD` (раздел 3.0). Ключевые этапы:
1.  Менеджер согласия (`initializeConsentManager`).
2.  Инициализация ядра (`initCore`), включая асинхронную инициализацию WebGPU сцены (`initializeScene`). Обработка ошибок WebGPU.
3.  Инициализация основного UI (`initializeMainUI`).
4.  Настройка кнопки "Start Session".
5.  Инициализация мультимедиа (`initializeMultimedia`) по действию пользователя, включая настройку аудиоконтекста, AudioWorklet (`waveletAnalyzer.js`) для CWT-анализа и передачу данных в `state`.
6.  Инициализация прочих сервисов (Firebase Auth, MediaPipe Hands, AI-модули, платформо-зависимые менеджеры).
7.  Запуск цикла анимации (`startAnimationLoop`).

**3.2. Взаимодействие Пользователя (Жест -> Результат)**
1.  **Ввод (Frontend):** Пользователь совершает жест. `handsTracking.js` (MediaPipe) -> `AtomicGestureClassifier.js` -> `GestureSequencer.js`.
2.  **Команда (Frontend):** `GestureSequencer` генерирует команду (например, `CREATE_CUBE`).
3.  **Обработка (Frontend/Backend):**
    *   Простые команды могут обрабатываться на клиенте (`main.js` обновляет UI/3D сцену).
    *   Сложные команды или требующие сохранения состояния/AI обработки отправляются на FastAPI бэкенд.
4.  **Ответ (Backend -> Frontend):** FastAPI возвращает результат, Frontend обновляет UI/голограмму.

**3.3. Загрузка "Чанка" Взаимодействия**
1.  **Формирование "Чанка" (Frontend):** Клиентский JavaScript собирает данные взаимодействия (аудио, видео/жесты, метаданные, `user_id`).
2.  **Запрос на Загрузку (Frontend -> Backend):** Клиент (через `apiService.js`) отправляет файл и метаданные на специальный эндпоинт FastAPI (например, `/api/v1/upload-chunk`).
3.  **Обработка Загрузки (Backend - FastAPI):**
    *   FastAPI эндпоинт принимает файл.
    *   Проверяет аутентификацию пользователя (JWT).
    *   Генерирует уникальный ключ объекта для R2.
    *   Использует `boto3` для загрузки файла напрямую в Cloudflare R2.
    *   В случае успеха, возвращает клиенту подтверждение и, возможно, идентификатор чанка.
    *   В случае ошибки, возвращает соответствующий код ошибки.
4.  **Сохранение Метаданных (Backend - FastAPI):** После успешной загрузки файла в R2, FastAPI сохраняет метаданные чанка (включая `object_key` из R2, `user_id`, `timestamp` и т.д.) в базу данных Neon.tech PostgreSQL.

**3.4. Обработка "Чанка" и Логика Триа (Backend - FastAPI/Genkit)**
1.  **Инициация Обработки:** После сохранения метаданных чанка, FastAPI инициирует его обработку логикой Триа. Это может быть прямой вызов Genkit flow или постановка задачи в очередь.
2.  **Выполнение Genkit Flow:**
    *   Genkit flow получает данные чанка (метаданные из БД, при необходимости файл из R2).
    *   Запускаются соответствующие AI-агенты/боты (GestureBot, AudioBot, MemoryBot и т.д.) в рамках flow.
    *   Происходит анализ данных, взаимодействие с LLM, поиск по базе знаний (RAG).
3.  **Формирование Ответа:** Genkit flow формирует комплексный ответ (текст, команды для UI, аудио).
4.  **Возврат Ответа (Backend -> Frontend):** FastAPI отправляет ответ на фронтенд.
5.  **Реакция (Frontend):** Обновление UI, голограммы, воспроизведение аудио.

**3.5. Обучение Триа (Эволюционный Принцип - FastAPI/Genkit)**
1.  **Сбор Данных:** Все "чанки" и обратная связь от пользователя сохраняются (файлы в R2, метаданные в Neon.tech).
2.  **Работа LearningBot (Genkit Flow):** Периодически или по триггеру запускается LearningBot flow:
    *   Анализирует эффективность предыдущих взаимодействий.
    *   Генерирует/мутирует конфигурации ботов, эвристики, параметры моделей.
    *   Тестирует новые варианты.
    *   Обновляет базу знаний и активные модели/конфигурации Триа.

---

**4. Основные Директивы для Разработки и Взаимодействия**
(Повторение из Версии 35.0, для полноты)
*   **Приоритет Задач:** Всегда следовать приоритетам, указанным в текущем задании. При возникновении конфликтов или неясностей, запрашивать уточнения.
*   **Качество Кода:** Писать чистый, эффективный и хорошо документированный код. Придерживаться установленных стандартов кодирования.
*   **Безопасность:** Уделять первостепенное внимание вопросам безопасности на всех этапах разработки.
*   **Тестирование:** Тщательно тестировать все изменения перед их отправкой. Автоматизированные тесты – обязательны.
*   **Отчетность:** Регулярно и подробно отчитываться о проделанной работе, возникших проблемах и достигнутых результатах. Использовать `submit_subtask_report`.

---

**5. Взаимодействие с Инструментами**
(Повторение из Версии 35.0, для полноты)
*   Использовать предоставленные инструменты (`ls`, `read_files`, `create_file_with_block`, `overwrite_file_with_block`, `delete_file`, `rename_file`, `grep`, `replace_with_git_merge_diff`, `run_in_bash_session`, `view_text_website`, `submit_subtask_report`) строго по их назначению.
*   Внимательно изучать вывод инструментов и реагировать на ошибки или предупреждения.
*   При использовании `replace_with_git_merge_diff`, `create_file_with_block`, и `overwrite_file_with_block` следовать точному синтаксису DSL.
*   Для `run_in_bash_session` использовать команды, подходящие для окружения Ubuntu VM. Устанавливать зависимости, если это необходимо (`apt-get`, `pip`, `npm`).

---

**6. Процедура Обновления Данной Системной Инструкции**
*   Этот документ (`holograms.media/docs/SYSTEM_INSTRUCTION_CURRENT.md`) является единственным источником правды для системных инструкций.
*   Любые обновления должны производиться путем прямого редактирования этого файла с использованием `overwrite_file_with_block` или `replace_with_git_merge_diff`.
*   После обновления, необходимо подтвердить, что используется последняя версия инструкции, указав номер версии и дату актуализации.

---

**7. Протокол Архитектурной Целостности и Стратегического Исполнения (Версия 5.0)**

[Начало Протокола]

**ЭТАП 0: Подготовка и Анализ**
1. Ознакомление с Задачей: Внимательное изучение постановки задачи, требований и ожидаемых результатов.
2. Анализ Контекста: Понимание места задачи в общей архитектуре проекта и ее влияния на другие компоненты.
3. Анализ и Верификация Скриптов Окружения:
    Действие: Перед началом работы изучите скрипты, определенные в конфигурации рабочего окружения (Initial setup, Repo commands). Убедитесь, что они соответствуют реальной структуре проекта (пути к package.json, requirements.txt).
    Цель: Предотвратить сбои на этапе настройки окружения.

**ЭТАП 1: Проектирование и Планирование**
1. Выбор Технологий и Подходов: Обоснованный выбор инструментов, библиотек и паттернов проектирования.
2. Декомпозиция Задачи: Разбиение сложной задачи на более мелкие, управляемые подзадачи.
3. Оценка Трудозатрат и Рисков: Предварительная оценка времени, необходимого для выполнения, и выявление потенциальных рисков.

**ЭТАП 2: Реализация и Тестирование**
1. Написание Кода: Следование стандартам кодирования, обеспечение чистоты и читаемости кода.
2. Модульное Тестирование: Создание и запуск тестов для проверки корректности отдельных модулей.
3. Интеграционное Тестирование: Проверка взаимодействия между различными компонентами системы.
4. Принцип "Живого Контроля" / "Аудита Сборки" (для задач Frontend):
    Действие: При работе в интерактивной среде (VS Code + терминал) основной метод — запуск npm run dev и анализ вывода Vite в реальном времени. В ограниченных средах (Jules), где dev сервер падает по таймауту, основной метод — запуск npm run build для получения полного списка ошибок сборки за один раз.
    Цель: Использовать Vite как основной инструмент для диагностики проблем с зависимостями и синтаксисом.

**ЭТАП 3: Ревью и Документирование**
1. Код-Ревью: Проведение взаимной проверки кода другими членами команды.
2. Обновление Документации: Актуализация технической документации, включая комментарии в коде и внешние описания.

**ЭТАП 4: Развертывание и Мониторинг**
1. Подготовка к Развертыванию: Конфигурирование окружения, проверка зависимостей.
2. Развертывание: Перенос изменений на тестовые или продуктивные серверы.
3. Мониторинг и Обратная Связь: Отслеживание работы системы после развертывания, сбор и анализ обратной связи.

**1. Общие Положения:**

*   **1.1. Назначение:** Настоящий Протокол определяет процедуры и стандарты для обеспечения архитектурной целостности разрабатываемых систем и стратегического соответствия всех вносимых изменений долгосрочным целям проекта "Holograms".
*   **1.2. Область Применения:** Действие Протокола распространяется на все этапы жизненного цикла разработки, включая проектирование, реализацию, тестирование, развертывание и сопровождение.
*   **1.3. Ответственность:** Ответственность за соблюдение Протокола лежит на всех участниках команды разработки. Архитекторы и ведущие разработчики несут особую ответственность за его внедрение и контроль.

**2. Принципы Архитектурной Целостности:**

*   **2.1. Модульность и Связность:** Системы должны проектироваться как набор слабо связанных, но сильно сплоченных модулей.
*   **2.2. Масштабируемость и Производительность:** Архитектурные решения должны обеспечивать возможность горизонтального и вертикального масштабирования, а также соответствовать требуемым показателям производительности.
*   **2.3. Отказоустойчивость и Надежность:** Системы должны быть спроектированы с учетом возможных сбоев и обеспечивать непрерывность работы критически важных функций.
*   **2.4. Безопасность:** Принципы безопасного проектирования (Security by Design) должны применяться на всех уровнях архитектуры.
*   **2.5. Поддерживаемость и Расширяемость:** Архитектура должна способствовать легкости внесения изменений, добавлению нового функционала и исправлению ошибок. Код должен быть понятным и хорошо документированным.

**3. Процедура Утверждения Архитектурных Решений:**

*   **3.1. Предложение Изменений:** Любые значительные архитектурные изменения должны быть оформлены в виде проектного предложения, включающего описание проблемы, предлагаемое решение, анализ влияния на существующую систему и оценку рисков.
*   **3.2. Ревью и Обсуждение:** Проектное предложение проходит процедуру ревью командой архитекторов и ведущих разработчиков. Результаты ревью фиксируются.
*   **3.3. Утверждение:** Решение об утверждении или отклонении предложения принимается на основе консенсуса или, в спорных случаях, решением главного архитектора проекта.
*   **3.4. Документирование:** Все утвержденные архитектурные решения должны быть подробно задокументированы и доступны всем членам команды.

**4. Стратегическое Исполнение:**

*   **4.1. Соответствие Дорожной Карте:** Все разрабатываемые функции и вносимые изменения должны соответствовать утвержденной дорожной карте проекта.
*   **4.2. Приоритизация:** Задачи выполняются в соответствии с установленными приоритетами, отражающими стратегическую важность и бизнес-ценность.
*   **4.3. Контроль Качества на Ранних Этапах:** Процедуры контроля качества, включая код-ревью и автоматизированное тестирование, должны применяться с самых ранних этапов разработки для предотвращения накопления технического долга.
*   **4.4. Обратная Связь и Итеративность:** Процесс разработки должен быть итеративным, с регулярным сбором обратной связи от заинтересованных сторон и внесением необходимых корректировок.

**5. Заключительные Положения:**

*   **5.1. Обновление Протокола:** Настоящий Протокол подлежит регулярному пересмотру и обновлению (не реже одного раза в год или по мере необходимости).
*   **5.2. Разрешение Конфликтов:** Любые разногласия, возникающие в процессе применения настоящего Протокола, разрешаются путем обсуждения и, при необходимости, эскалации до руководства проекта.

(Конец Протокола)

---

**8. Глоссарий**
(Адаптировано из `docs/RU/Architecture/SystemDescription.MD`, раздел 4, и актуализировано)

*   **Голограмма (Hologram):** Динамическая, интерактивная 3D-аудиовизуализация данных, генерируемая с помощью Three.js/WebGPU.
*   **Триа (Tria):** AI-ядро проекта, самообучающийся AI-ассистент. Логика AI реализуется и оркестрируется с помощью Genkit, интегрированного в FastAPI бэкенд.
*   **Комбинированный Чанк Взаимодействия (Interaction Chunk):** Синхронизированный набор данных (аудио, видео, жесты, метаданные), фиксирующий одно взаимодействие пользователя. Файлы загружаются в Cloudflare R2, метаданные сохраняются в Neon.tech PostgreSQL.
*   **Frontend (Firebase Hosting):** Клиентское веб-приложение, отвечающее за UI, рендеринг и захват пользовательского ввода.
*   **Backend (FastAPI на Koyeb):** Основной сервер приложений (Python/FastAPI), развернутый на Koyeb. Обрабатывает API, бизнес-логику, AI-оркестрацию.
*   **Neon.tech PostgreSQL + pgvector:** Основная реляционная база данных с возможностью хранения векторных представлений.
*   **Cloudflare R2:** S3-совместимое объектное хранилище для "чанков" и других медиа-файлов.
*   **Genkit:** Фреймворк для разработки и выполнения AI-потоков (flows), интегрированный с FastAPI.
*   **Firebase Authentication:** Сервис для аутентификации пользователей.
*   **Firebase Cloud Functions:** Вспомогательные серверные функции для специфических задач Firebase.
*   **MediaPipe Hands:** Технология Google для отслеживания ключевых точек рук.
*   **AtomicGestureClassifier.js:** Frontend модуль для классификации статических ("атомарных") жестов.
*   **GestureSequencer.js:** Frontend модуль для распознавания последовательностей атомарных жестов.
*   **CWT (Continuous Wavelet Transform):** Непрерывное вейвлет-преобразование, используемое для анализа аудиосигналов. Реализовано на Rust/WASM и выполняется в AudioWorklet (`waveletAnalyzer.js`).
*   **WASM (WebAssembly):** Бинарный формат инструкций для выполнения кода с производительностью, близкой к нативной, в веб-браузерах.
*   **Koyeb:** Платформа для развертывания серверных приложений, включая Docker-контейнеры.
*   **Pydantic:** Библиотека Python для валидации данных, используемая в FastAPI.
*   **asyncpg:** Асинхронный драйвер PostgreSQL для Python.
*   **boto3:** AWS SDK для Python, используется для взаимодействия с Cloudflare R2 (S3-совместимый API).
*   **HoloGraph:** Децентрализованная экономическая экосистема на базе токенов (долгосрочное R&D).

[Конец Системной Инструкции]
